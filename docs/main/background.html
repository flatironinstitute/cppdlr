<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Background &mdash; cppdlr  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=default"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="Installation" href="install.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #7E588A" >

          
          
          <a href="index.html" class="icon icon-home">
            cppdlr
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="install.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#installation-steps">Installation steps</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#versions">Versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#custom-cmake-options">Custom CMake options</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#compiling-with-clang">Compiling with clang</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#note-for-macos-users">Note for MacOS users</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Background</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#imaginary-time-green-s-functions-and-the-lehmann-representation">Imaginary time Green’s functions and the Lehmann representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discrete-lehmann-representation">Discrete Lehmann representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constructing-a-dlr-expansion">Constructing a DLR expansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dlr-in-the-matsubara-frequency-domain">DLR in the Matsubara frequency domain</a></li>
<li class="toctree-l2"><a class="reference internal" href="#operations-in-the-dlr-basis">Operations in the DLR basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#imaginary-time-point-format">Imaginary time point format</a></li>
<li class="toctree-l2"><a class="reference internal" href="#matsubara-frequency-point-format">Matsubara frequency point format</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples.html#example-form-a-dlr-expansion-via-interpolation-and-evaluate-it-in-imaginary-time-and-frequency">Example: form a DLR expansion via interpolation, and evaluate it in imaginary time and frequency</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#list-of-examples">List of examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#list-of-other-cppdlr-capabilities">List of other <code class="docutils literal notranslate"><span class="pre">cppdlr</span></code> capabilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Reference documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Reporting issues</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #7E588A" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cppdlr</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Background</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/background.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="background">
<span id="id1"></span><h1>Background<a class="headerlink" href="#background" title="Permalink to this heading"></a></h1>
<p>This page gives a brief review of the discrete Lehmann representation (DLR), and
establishes the definitions and conventions used in <code class="docutils literal notranslate"><span class="pre">cppdlr</span></code> (which can vary
from one reference to another). If you are already familiar with the DLR, you
should probably still read <a class="reference internal" href="#relativeformat"><span class="std std-ref">the section on the relative imaginary time
format below</span></a>. For a more detailed description of the DLR,
please see the references listed on the <a class="reference internal" href="index.html#main"><span class="std std-ref">main page</span></a>. For examples of
the implementation of these concepts in <code class="docutils literal notranslate"><span class="pre">cppdlr</span></code>, please see the
<a class="reference internal" href="examples.html#examples"><span class="std std-ref">examples page</span></a>.</p>
<div class="section" id="imaginary-time-green-s-functions-and-the-lehmann-representation">
<h2>Imaginary time Green’s functions and the Lehmann representation<a class="headerlink" href="#imaginary-time-green-s-functions-and-the-lehmann-representation" title="Permalink to this heading"></a></h2>
<p>The single-particle imaginary time Green’s function is defined in terms of the time-ordered expectation value as</p>
<div class="math notranslate nohighlight">
\[G_{ab}(\tau) = - \langle \mathcal{T} c_a(\tau) c_b^\dagger(0) \rangle,\]</div>
<p>where <span class="math notranslate nohighlight">\(c^\dagger_b(0)\)</span> is the creation operator for a particle in state <span class="math notranslate nohighlight">\(b\)</span> at time <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(c_a(\tau)\)</span> is the annihilation operator for a particle in state <span class="math notranslate nohighlight">\(a\)</span> at time <span class="math notranslate nohighlight">\(\tau\)</span>. The Green’s function is defined on the interval <span class="math notranslate nohighlight">\(\tau \in (0, \beta)\)</span>, where <span class="math notranslate nohighlight">\(\beta\)</span> is the inverse temperature, but it can be extended to <span class="math notranslate nohighlight">\(\tau \in (-\beta, 0)\)</span> using the periodicity and anti-periodicity properties</p>
<div class="math notranslate nohighlight">
\[G_{ab}(\tau) = \xi G_{ab}(\beta + \tau),\]</div>
<p>of bosonic (<span class="math notranslate nohighlight">\(\xi = 1\)</span>) and fermionic (<span class="math notranslate nohighlight">\(\xi = -1\)</span>) particles, respectively.</p>
<p>The spectral Lehmann representation of a Green’s function is given by</p>
<div class="math notranslate nohighlight">
\[G(\tau) = \int_{-\infty}^\infty K(\tau,\omega) \rho(\omega) \, d\omega,\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho(\omega)\)</span> is the spectral function corresponding to the Green’s
function <span class="math notranslate nohighlight">\(G\)</span>, and <span class="math notranslate nohighlight">\(K(\tau,\omega)\)</span> is the analytic continuation
kernel, given by</p>
<div class="math notranslate nohighlight">
\[K(\tau, \omega) = -\frac{e^{-\omega \tau}}{1 + e^{-\beta \omega}}.\]</div>
<p>Taking the Fourier transform to the imaginary (or Matsubara) frequency domain
gives</p>
<div class="math notranslate nohighlight">
\[G(i \nu_n) = \int_{-\infty}^\infty K(i \nu_n,\omega) \rho(\omega) \, d\omega,\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[K(i \nu_n, \omega) = \frac{1}{i\nu_n - \omega}\]</div>
<p>for fermionic Green’s functions, and</p>
<div class="math notranslate nohighlight">
\[K(i \nu_n, \omega) = \frac{\tanh (\beta \omega/2)}{i\nu_n - \omega}\]</div>
<p>for bosonic Green’s functions. Here, the Matsubara frequencies are defined as
<span class="math notranslate nohighlight">\(i \nu_n = 2 n \pi i/\beta\)</span> and <span class="math notranslate nohighlight">\(i \nu_n = (2n+1) \pi i/\beta\)</span> for
bosonic and fermionic Green’s functions, respectively.</p>
</div>
<div class="section" id="discrete-lehmann-representation">
<h2>Discrete Lehmann representation<a class="headerlink" href="#discrete-lehmann-representation" title="Permalink to this heading"></a></h2>
<p>The discrete Lehmann representation (DLR) is constructed by making a low-rank
approximation of the analytic continuation kernel (using the <a class="reference external" href="https://epubs.siam.org/doi/10.1137/030602678" rel="noopener noreferrer" target="_blank">interpolative
decomposition</a>). Let us define
the dimensionless cutoff paramter <span class="math notranslate nohighlight">\(\Lambda \equiv \beta \omega_{\max}\)</span>,
where <span class="math notranslate nohighlight">\(\omega_{\max}\)</span> is defined such that <span class="math notranslate nohighlight">\(\rho(\omega) = 0\)</span>
outside of <span class="math notranslate nohighlight">\([-\omega_{\max},\omega_{\max}]\)</span>. In practice, <span class="math notranslate nohighlight">\(\beta\)</span> is
typically known, and <span class="math notranslate nohighlight">\(\omega_{\max}\)</span> can be estimated. <span class="math notranslate nohighlight">\(\Lambda\)</span> is
a user-specified parameter, and in the typical case that <span class="math notranslate nohighlight">\(\omega_{\max}\)</span>
is not known exactly, results can be converged with respect to <span class="math notranslate nohighlight">\(\Lambda\)</span>.
Given <span class="math notranslate nohighlight">\(\Lambda\)</span> and another user-specified error tolerance parameter
<span class="math notranslate nohighlight">\(\epsilon\)</span>, the DLR expansion of an imaginary time Green’s function
<span class="math notranslate nohighlight">\(G(\tau)\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[\begin{equation}
  G(\tau) \approx \sum_{l=1}^r K(\tau,\omega_l) \widehat{g}_l, \label{dlrexp} \tag{1}
\end{equation}\]</div>
<p>with equality to accuracy <span class="math notranslate nohighlight">\(\epsilon\)</span>. Here, the <span class="math notranslate nohighlight">\(r\)</span> <em>DLR frequencies</em>
<span class="math notranslate nohighlight">\(\omega_l\)</span> determining the <em>DLR basis functions</em> <span class="math notranslate nohighlight">\(K(\tau,\omega_l)\)</span>
are carefully chosen (by a pivoted Gram-Schmidt procedure) depending only on
<span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\epsilon\)</span>, but <em>not</em> on <span class="math notranslate nohighlight">\(G\)</span> itself. As for the
closely related <a class="reference external" href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.96.035147" rel="noopener noreferrer" target="_blank">intermediate representation</a>
(implemented, for example, in <a class="reference external" href="https://github.com/SpM-lab/sparse-ir" rel="noopener noreferrer" target="_blank">sparse-ir</a>), for which the basis functions are
orthogonal but non-explicit, we have <span class="math notranslate nohighlight">\(r = \mathcal{O}(\log(\Lambda)
\log(\epsilon^{-1}))\)</span>. Thus the DLR enables a highly efficient and high-order
accurate discretization of all imaginary time Green’s functions, with a number
of degrees of freedom independent of the specific structure of a given Green’s
function (beyond its cutoff parameter <span class="math notranslate nohighlight">\(\Lambda\)</span>).</p>
</div>
<div class="section" id="constructing-a-dlr-expansion">
<h2>Constructing a DLR expansion<a class="headerlink" href="#constructing-a-dlr-expansion" title="Permalink to this heading"></a></h2>
<p>In practice, the <em>DLR coefficients</em> <span class="math notranslate nohighlight">\(\widehat{g}_l\)</span> must be determined
from some samples of <span class="math notranslate nohighlight">\(G(\tau)\)</span>. This can be done by fitting to data, e.g.
via ordinary least squares, or by <em>interpolation</em> at the <em>DLR imaginary time
nodes</em> <span class="math notranslate nohighlight">\(\tau_k\)</span>. These are <span class="math notranslate nohighlight">\(r\)</span> imaginary time points which, given
the DLR frequencies <span class="math notranslate nohighlight">\(\omega_l\)</span>, are also chosen by a pivoted Gram-Schmidt
procedure. In particular, given the values <span class="math notranslate nohighlight">\(G(\tau_k)\)</span>, we can solve the
<span class="math notranslate nohighlight">\(r \times r\)</span> linear system (or interpolation problem)</p>
<div class="math notranslate nohighlight">
\[G(\tau_k) = \sum_{l=1}^r K(\tau_k,\omega_l) \widehat{g}_l\]</div>
<p>to obtain the DLR coefficients. <span class="math notranslate nohighlight">\(G(\tau)\)</span> can then be evaluated using its
DLR expansion <span class="math notranslate nohighlight">\(\eqref{dlrexp}\)</span>.</p>
</div>
<div class="section" id="dlr-in-the-matsubara-frequency-domain">
<h2>DLR in the Matsubara frequency domain<a class="headerlink" href="#dlr-in-the-matsubara-frequency-domain" title="Permalink to this heading"></a></h2>
<p>Fourier transform of <span class="math notranslate nohighlight">\(\eqref{dlrexp}\)</span> yields</p>
<div class="math notranslate nohighlight">
\[\begin{equation}
  G(i nu_n) \approx \sum_{l=1}^r K(i \nu_n,\omega_l) \widehat{g}_l, \label{dlrexp_imfreq} \tag{2}
\end{equation}\]</div>
<p>so we see that the DLR expansion can be evaluated directly in imaginary time or
imaginary frequency, i.e. the Fourier transform is performed analytically. As in
imaginary time, the DLR coefficients can be obtained by solving the
<span class="math notranslate nohighlight">\(r \times r\)</span> interpolation problem</p>
<div class="math notranslate nohighlight">
\[G(i \nu_{n_k}) = \sum_{l=1}^r K(i \nu_{n_k},\omega_l) \widehat{g}_l\]</div>
<p>at the <span class="math notranslate nohighlight">\(r\)</span> <em>DLR imaginary frequency nodes</em> <span class="math notranslate nohighlight">\(i \nu_{n_k}\)</span>, whereupon
<span class="math notranslate nohighlight">\(G(i \nu_n)\)</span> can be evaluated using <span class="math notranslate nohighlight">\(\eqref{dlrexp_imfreq}\)</span> (or
<span class="math notranslate nohighlight">\(G(\tau)\)</span> can be evaluated using <span class="math notranslate nohighlight">\(\eqref{dlrexp}\)</span>).</p>
</div>
<div class="section" id="operations-in-the-dlr-basis">
<h2>Operations in the DLR basis<a class="headerlink" href="#operations-in-the-dlr-basis" title="Permalink to this heading"></a></h2>
<p>Since the DLR basis functions are known analytically, common linear
operations can be straightforwardly performed by representing them in the DLR
basis. These include</p>
<ul class="simple">
<li>Fourier transform: as explained above, one can switch between imaginary time
and imaginary frequency representations via the DLR expansion, with no
additional Fourier transform operation</li>
<li>Products: in imaginary time or imaginary frequency, by simply multiplying the
functions on the DLR grid, i.e. <span class="math notranslate nohighlight">\(H(\tau_k) = F(\tau_k) G(\tau_k)\)</span>,
whereupon the DLR expansion of the result can be recovered</li>
<li>Imaginary time convolution: this includes the full convolution
<span class="math notranslate nohighlight">\(H(\tau) = \int_0^\beta F(\tau-\tau') G(\tau') \, d\tau'\)</span>, which requires using the
periodicity/anti-periodicity condition, or the time-ordered convolution
<span class="math notranslate nohighlight">\(H(\tau) = \int_0^\tau F(\tau-\tau') G(\tau') \, d\tau\)</span></li>
<li>Linear functionals: e.g. inner products with a given function, evaluation at a point, etc…</li>
</ul>
<p>All such operations take the form of vectors/matrices/tensors acting on <span class="math notranslate nohighlight">\(r
\times 1\)</span> vectors, which represent the DLR expansion of a Green’s function
<span class="math notranslate nohighlight">\(G\)</span> (either the vector of DLR coefficients of <span class="math notranslate nohighlight">\(G\)</span>, or the vector of
values of <span class="math notranslate nohighlight">\(G\)</span> at the DLR nodes). Common operations are implemented in
<code class="docutils literal notranslate"><span class="pre">cppdlr</span></code> in a user-friendly manner, and the implementation of new operations
should be requested on the <a class="reference external" href="https://github.com/flatironinstitute/cppdlr/issues" rel="noopener noreferrer" target="_blank">GitHub issues page</a>.</p>
</div>
<div class="section" id="imaginary-time-point-format">
<span id="relativeformat"></span><h2>Imaginary time point format<a class="headerlink" href="#imaginary-time-point-format" title="Permalink to this heading"></a></h2>
<p>First, in <code class="docutils literal notranslate"><span class="pre">cppdlr</span></code> imaginary time points are scaled from the interval
<span class="math notranslate nohighlight">\([0,\beta]\)</span> to the interval <span class="math notranslate nohighlight">\([0,1]\)</span>. This is because <code class="docutils literal notranslate"><span class="pre">cppdlr</span></code>
works with dimensionless variables whenever possible, so in many functions it is
unnecessary to specify the inverse temperature <span class="math notranslate nohighlight">\(\beta\)</span> explicitly.</p>
<p>Second, <code class="docutils literal notranslate"><span class="pre">cppdlr</span></code> stores imaginary time points in a peculiar manner, called the
<em>relative</em> time format.
<strong>This is a subtle issue which ``cppdlr`` users should be aware of, in
particular if one wants to supply imaginary time points at which to
evaluate a DLR expansion.</strong> For the TLDR, skip to the <strong>guidelines</strong> below. For an even
more detailed discussion of this issue than the one given here, see Appendix C
of <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0010465522001771" rel="noopener noreferrer" target="_blank">this paper</a>.</p>
<p>The relative time format works as follows. Points <span class="math notranslate nohighlight">\(\tau \in [0, 0.5]\)</span> are
represented normally. However, instead of representing points <span class="math notranslate nohighlight">\(\tau \in
(0.5,1)\)</span> directly, we instead store the number <span class="math notranslate nohighlight">\(\tau^* = \tau-1\)</span>. In other
words, we store the negative distance of <span class="math notranslate nohighlight">\(\tau\)</span> to 1, rather than tau
itself. Recovering <span class="math notranslate nohighlight">\(\tau\)</span> in the standard <em>absolute time format</em> is
straightforward, and is implemented by the function <code class="docutils literal notranslate"><span class="pre">rel2abs</span></code>.</p>
<p>The reason for this has to do with maintaining full relative accuracy in
floating point arithmetic. To evaluate the kernel <span class="math notranslate nohighlight">\(K(\tau,\omega)\)</span>, we
sometimes need to compute the value <span class="math notranslate nohighlight">\(1-\tau\)</span> for <span class="math notranslate nohighlight">\(\tau\)</span> very close to 1. If we
work with tau directly, there is a loss of accuracy due to catastrophic
cancellation, which begins to appear in extreme physical regimes and at
very high requested accuracies. If we instead compute <span class="math notranslate nohighlight">\(\tau^*\)</span> to full relative accuracy and
work with it directly rather than with <span class="math notranslate nohighlight">\(\tau\)</span>, for example by exploiting
symmetries of <span class="math notranslate nohighlight">\(K(\tau,\omega)\)</span> to avoid ever evaluating <span class="math notranslate nohighlight">\(1-\tau\)</span>, we can
maintain full relative accuracy.</p>
<p>This annoyance is the price of maintaining full accuracy in floating point
arithmic. But it is largely ignoreable if the loss of accuracy is not noticeable
in your application, as will be the case for many users.</p>
<p><strong>Simply follow these guidelines</strong>:</p>
<ol class="arabic simple">
<li>Use functions provided by <code class="docutils literal notranslate"><span class="pre">cppdlr</span></code> to carry out all imaginary time
operations whenever possible. This will usually hide this technical
complication.</li>
<li>In a situation in which you want to provide a point <span class="math notranslate nohighlight">\(\tau\)</span>
at which to evaluate a DLR, there are two options:<ul>
<li>(The power user option) Compute <span class="math notranslate nohighlight">\(\tau^*\)</span>, defined above, to full relative accuracy, and provide this according to
the instructions in the relevant functions, thereby maintaining full
relative accuracy in calculations, or</li>
<li>(The typical user option) If you don’t care about the (usually minor) digit
loss which comes from ignoring this subtlety, simply convert your point
<span class="math notranslate nohighlight">\(\tau\)</span> in the standard, absolute format (a point <span class="math notranslate nohighlight">\(\tau \in
[0,1]\)</span>) to the relative format
<span class="math notranslate nohighlight">\(\tau^*\)</span> defined above using the <code class="docutils literal notranslate"><span class="pre">abs2rel</span></code> function. Since the point will have
started its life in the absolute format, converting it to relative format
cannot recover full relative accuracy, but it still needs to be converted
in order to be compatible with <code class="docutils literal notranslate"><span class="pre">cppdlr</span></code> subroutines.</li>
</ul>
</li>
<li>If you happen to want to evaluate a Green’s function on an
equispaced grid on <span class="math notranslate nohighlight">\([0,1]\)</span> in imaginary time, use the function <code class="docutils literal notranslate"><span class="pre">eqpts_rel</span></code>
to generate this grid in the relative format.</li>
</ol>
</div>
<div class="section" id="matsubara-frequency-point-format">
<h2>Matsubara frequency point format<a class="headerlink" href="#matsubara-frequency-point-format" title="Permalink to this heading"></a></h2>
<p>We define the Matsubara (or imaginary) frequency points as <span class="math notranslate nohighlight">\(i \nu_n = (2 n
+ 1) \pi i/\beta\)</span> for fermionic Green’s functions, and <span class="math notranslate nohighlight">\(i \nu_n = 2 n \pi
i/\beta\)</span> for bosonic Green’s functions. In <code class="docutils literal notranslate"><span class="pre">cppdlr</span></code>, Matsubara frequency
points are represented by specifying the integer <code class="docutils literal notranslate"><span class="pre">n</span></code>, the inverse temperature
<span class="math notranslate nohighlight">\(\beta\)</span>, and whether the point is a fermionic or bosonic Matsubara
frequency using the <code class="docutils literal notranslate"><span class="pre">statistic_t</span></code> specifier.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="install.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="examples.html" class="btn btn-neutral float-right" title="Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 The Simons Foundation, Hugo U.R. Strand. Authors: J. Kaye, N. Wentzell, H. U. R. Strand.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>