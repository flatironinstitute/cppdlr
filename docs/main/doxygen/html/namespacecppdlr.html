<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppdlr: cppdlr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">cppdlr<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Imaginary time calculations using the discrete Lehmann representation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">cppdlr Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1barycheb.html">barycheb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1baryleg.html">baryleg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1dyson__it.html">dyson_it</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for solving Dyson equation in imaginary time.  <a href="classcppdlr_1_1dyson__it.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class containing parameters for fine composite Chebyshev grid discretizations of imaginary time and frequency.  <a href="classcppdlr_1_1fineparams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imfreq__ops.html">imfreq_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class responsible for all DLR imaginary frequency operations, including building imaginary frequency grid and transformations.  <a href="classcppdlr_1_1imfreq__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations.  <a href="classcppdlr_1_1imtime__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppdlr_1_1make__common__helper.html">make_common_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of given nda MemoryArray with scalar value type replaced by common type of two given types (real if both are real, complex otherwise)  <a href="structcppdlr_1_1make__common__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83cde5c4ed014eb53f7c16392a41733e" id="r_a83cde5c4ed014eb53f7c16392a41733e"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a83cde5c4ed014eb53f7c16392a41733e">build_rf_fine</a> (<a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;fine)</td></tr>
<tr class="memdesc:a83cde5c4ed014eb53f7c16392a41733e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build fine composite Chebyshev grid in real frequency.  <br /></td></tr>
<tr class="separator:a83cde5c4ed014eb53f7c16392a41733e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa672c293b0b90ab5045fbb091a1ed57" id="r_afa672c293b0b90ab5045fbb091a1ed57"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#afa672c293b0b90ab5045fbb091a1ed57">build_it_fine</a> (<a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;fine)</td></tr>
<tr class="memdesc:afa672c293b0b90ab5045fbb091a1ed57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get fine composite Legendre grid in imaginary time and corresponding square root quadrature weights.  <br /></td></tr>
<tr class="separator:afa672c293b0b90ab5045fbb091a1ed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c50dbbe81c1821676393f8584fb3f6" id="r_a38c50dbbe81c1821676393f8584fb3f6"><td class="memItemLeft" align="right" valign="top">nda::matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a38c50dbbe81c1821676393f8584fb3f6">build_k_it</a> (nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; om)</td></tr>
<tr class="memdesc:a38c50dbbe81c1821676393f8584fb3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel.  <br /></td></tr>
<tr class="separator:a38c50dbbe81c1821676393f8584fb3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6df2a0cc73644667ba77bf562a9e140" id="r_ad6df2a0cc73644667ba77bf562a9e140"><td class="memItemLeft" align="right" valign="top">nda::matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ad6df2a0cc73644667ba77bf562a9e140">build_k_it</a> (nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; w, nda::vector_const_view&lt; double &gt; om)</td></tr>
<tr class="memdesc:ad6df2a0cc73644667ba77bf562a9e140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel with L^2 weighting.  <br /></td></tr>
<tr class="separator:ad6df2a0cc73644667ba77bf562a9e140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab471fd1439bcd11be6bc10de9703138a" id="r_ab471fd1439bcd11be6bc10de9703138a"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ab471fd1439bcd11be6bc10de9703138a">build_k_it</a> (double t, nda::vector_const_view&lt; double &gt; om)</td></tr>
<tr class="memdesc:ab471fd1439bcd11be6bc10de9703138a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel.    <br /></td></tr>
<tr class="separator:ab471fd1439bcd11be6bc10de9703138a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b931a8f12802eee8e74307c655ca85" id="r_ad4b931a8f12802eee8e74307c655ca85"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ad4b931a8f12802eee8e74307c655ca85">build_k_it</a> (nda::vector_const_view&lt; double &gt; t, double om)</td></tr>
<tr class="memdesc:ad4b931a8f12802eee8e74307c655ca85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel.    <br /></td></tr>
<tr class="separator:ad4b931a8f12802eee8e74307c655ca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45377bb09b54d66487cf379b1a6037de" id="r_a45377bb09b54d66487cf379b1a6037de"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a45377bb09b54d66487cf379b1a6037de">build_k_it</a> (nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; w, double om)</td></tr>
<tr class="memdesc:a45377bb09b54d66487cf379b1a6037de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel with L^2 weighting.    <br /></td></tr>
<tr class="separator:a45377bb09b54d66487cf379b1a6037de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb848c5a66d6141ad240d2e749aec9" id="r_a48fb848c5a66d6141ad240d2e749aec9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a48fb848c5a66d6141ad240d2e749aec9">geterr_k_it</a> (<a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;fine, nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; om, nda::matrix_const_view&lt; double &gt; kmat)</td></tr>
<tr class="memdesc:a48fb848c5a66d6141ad240d2e749aec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get error of fine composite Chebyshev discretization of analytic continuation kernel in imaginary time.  <br /></td></tr>
<tr class="separator:a48fb848c5a66d6141ad240d2e749aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988f80420d11cd80ac3803bd3bd429c0" id="r_a988f80420d11cd80ac3803bd3bd429c0"><td class="memItemLeft" align="right" valign="top">nda::matrix&lt; <a class="el" href="namespacecppdlr.html#a7b5392bb6f0a8155f1f19cab3bd042e9">dcomplex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a988f80420d11cd80ac3803bd3bd429c0">build_k_if</a> (int nmax, nda::vector_const_view&lt; double &gt; om, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic)</td></tr>
<tr class="memdesc:a988f80420d11cd80ac3803bd3bd429c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary frequency discretization of analytic continuation kernel.  <br /></td></tr>
<tr class="separator:a988f80420d11cd80ac3803bd3bd429c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f27d33c07f08031768f0844d14724e" id="r_a07f27d33c07f08031768f0844d14724e"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a07f27d33c07f08031768f0844d14724e">build_dlr_rf</a> (double lambda, double eps, bool symmetrize)</td></tr>
<tr class="memdesc:a07f27d33c07f08031768f0844d14724e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct DLR basis by obtaining DLR frequencies.  <br /></td></tr>
<tr class="separator:a07f27d33c07f08031768f0844d14724e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace84f47b6cc94a562dfd5207791c27b0" id="r_ace84f47b6cc94a562dfd5207791c27b0"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ace84f47b6cc94a562dfd5207791c27b0">build_dlr_rf</a> (double lambda, double eps)</td></tr>
<tr class="memdesc:ace84f47b6cc94a562dfd5207791c27b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct DLR basis by obtaining DLR frequencies.  <br /></td></tr>
<tr class="separator:ace84f47b6cc94a562dfd5207791c27b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02424caf43ace0c3330b2fa03f706400" id="r_a02424caf43ace0c3330b2fa03f706400"><td class="memTemplParams" colspan="2">template&lt;typename Ht &gt; <br />
requires (std::floating_point&lt;Ht&gt; || nda::MemoryMatrix&lt;Ht&gt;)</td></tr>
<tr class="memitem:a02424caf43ace0c3330b2fa03f706400"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a02424caf43ace0c3330b2fa03f706400">free_gf</a> (double beta, <a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;itops, Ht const &amp;h, double mu=0, bool time_order=false)</td></tr>
<tr class="memdesc:a02424caf43ace0c3330b2fa03f706400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute free-particle imaginary time Green's function for a given Hamiltonian.  <br /></td></tr>
<tr class="separator:a02424caf43ace0c3330b2fa03f706400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b753b1a7de53aff215a230206908e6d" id="r_a4b753b1a7de53aff215a230206908e6d"><td class="memTemplParams" colspan="2">template&lt;typename Ht &gt; <br />
requires (std::floating_point&lt;Ht&gt; || nda::MemoryMatrix&lt;Ht&gt;)</td></tr>
<tr class="memitem:a4b753b1a7de53aff215a230206908e6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a4b753b1a7de53aff215a230206908e6d">free_gf</a> (double beta, <a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;itops, Ht const &amp;h, bool time_order)</td></tr>
<tr class="memdesc:a4b753b1a7de53aff215a230206908e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute free-particle imaginary time Green's function for a given Hamiltonian.  <br /></td></tr>
<tr class="separator:a4b753b1a7de53aff215a230206908e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9726e02898098dfff8448f02f5b3c6" id="r_afc9726e02898098dfff8448f02f5b3c6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#afc9726e02898098dfff8448f02f5b3c6">k_it</a> (double t, double om)</td></tr>
<tr class="memdesc:afc9726e02898098dfff8448f02f5b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary time (relative time format) using dimensionless variables (beta = 1)  <br /></td></tr>
<tr class="separator:afc9726e02898098dfff8448f02f5b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfc4afda9cacac00e93425fe9d45a93" id="r_a3cfc4afda9cacac00e93425fe9d45a93"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a3cfc4afda9cacac00e93425fe9d45a93">k_it</a> (double t, double om, double beta)</td></tr>
<tr class="memdesc:a3cfc4afda9cacac00e93425fe9d45a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary time (relative time format) for a given inverse temperature.  <br /></td></tr>
<tr class="separator:a3cfc4afda9cacac00e93425fe9d45a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfaf907221eb1768418258421af703f" id="r_a7dfaf907221eb1768418258421af703f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a7dfaf907221eb1768418258421af703f">k_it_abs</a> (double t, double om)</td></tr>
<tr class="memdesc:a7dfaf907221eb1768418258421af703f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary time (absolute time format) using dimensionless variables (beta = 1)  <br /></td></tr>
<tr class="separator:a7dfaf907221eb1768418258421af703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66270b210c46b39737f361467f645be7" id="r_a66270b210c46b39737f361467f645be7"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a66270b210c46b39737f361467f645be7">k_if_fermion</a> (int n, double om)</td></tr>
<tr class="memdesc:a66270b210c46b39737f361467f645be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate fermionic analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1)  <br /></td></tr>
<tr class="separator:a66270b210c46b39737f361467f645be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73f52d9e0209e584d1210d419f39f8c" id="r_ab73f52d9e0209e584d1210d419f39f8c"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ab73f52d9e0209e584d1210d419f39f8c">k_if_boson</a> (int n, double om)</td></tr>
<tr class="memdesc:ab73f52d9e0209e584d1210d419f39f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate bosonic analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1)  <br /></td></tr>
<tr class="separator:ab73f52d9e0209e584d1210d419f39f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f77e12b089b5ddb5b5b3cda18cf623" id="r_af8f77e12b089b5ddb5b5b3cda18cf623"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#af8f77e12b089b5ddb5b5b3cda18cf623">k_if</a> (int n, double om, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic)</td></tr>
<tr class="memdesc:af8f77e12b089b5ddb5b5b3cda18cf623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1)  <br /></td></tr>
<tr class="separator:af8f77e12b089b5ddb5b5b3cda18cf623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672098c598c55c8f9da60cd194a741ea" id="r_a672098c598c55c8f9da60cd194a741ea"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a672098c598c55c8f9da60cd194a741ea">k_if</a> (int n, double om, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic, double beta)</td></tr>
<tr class="memdesc:a672098c598c55c8f9da60cd194a741ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary frequency for a given inverse temperature.  <br /></td></tr>
<tr class="separator:a672098c598c55c8f9da60cd194a741ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa355c3aaf829296d7e5869eff98fedd1" id="r_aa355c3aaf829296d7e5869eff98fedd1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#aa355c3aaf829296d7e5869eff98fedd1">baryinterp</a> (nda::vector_const_view&lt; double &gt; x, nda::vector_const_view&lt; double &gt; w, nda::vector_const_view&lt; double &gt; f, double xeval)</td></tr>
<tr class="memdesc:aa355c3aaf829296d7e5869eff98fedd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Barycentric Lagrange interpolation.  <br /></td></tr>
<tr class="separator:aa355c3aaf829296d7e5869eff98fedd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d46bf12944fe36c90343df67e2d783b" id="r_a2d46bf12944fe36c90343df67e2d783b"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a2d46bf12944fe36c90343df67e2d783b">eqptsrel</a> (int n)</td></tr>
<tr class="memdesc:a2d46bf12944fe36c90343df67e2d783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get grid of equispaced points on [0,1] in relative time format.  <br /></td></tr>
<tr class="separator:a2d46bf12944fe36c90343df67e2d783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ccba6393dfc517757677a13ad2553" id="r_a3b1ccba6393dfc517757677a13ad2553"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a3b1ccba6393dfc517757677a13ad2553">rel2abs</a> (nda::vector_const_view&lt; double &gt; t)</td></tr>
<tr class="memdesc:a3b1ccba6393dfc517757677a13ad2553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from relative to absolute time format.  <br /></td></tr>
<tr class="separator:a3b1ccba6393dfc517757677a13ad2553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373b198ea4a2d60eb80052dc0d4ae229" id="r_a373b198ea4a2d60eb80052dc0d4ae229"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a373b198ea4a2d60eb80052dc0d4ae229">rel2abs</a> (double t)</td></tr>
<tr class="memdesc:a373b198ea4a2d60eb80052dc0d4ae229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from relative to absolute time format.    <br /></td></tr>
<tr class="separator:a373b198ea4a2d60eb80052dc0d4ae229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103a8aae4c8af512d2682d381a676561" id="r_a103a8aae4c8af512d2682d381a676561"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a103a8aae4c8af512d2682d381a676561">abs2rel</a> (nda::vector_const_view&lt; double &gt; t_abs)</td></tr>
<tr class="memdesc:a103a8aae4c8af512d2682d381a676561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from absolute to relative time format.  <br /></td></tr>
<tr class="separator:a103a8aae4c8af512d2682d381a676561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b659aaebe1e52cf12edb3b089b224" id="r_a791b659aaebe1e52cf12edb3b089b224"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a791b659aaebe1e52cf12edb3b089b224">abs2rel</a> (double t_abs)</td></tr>
<tr class="memdesc:a791b659aaebe1e52cf12edb3b089b224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from relative to absolute time format.    <br /></td></tr>
<tr class="separator:a791b659aaebe1e52cf12edb3b089b224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfcb627a6ab1115bb02670e7ce61219" id="r_afbfcb627a6ab1115bb02670e7ce61219"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#afbfcb627a6ab1115bb02670e7ce61219">gaussquad</a> (int n)</td></tr>
<tr class="memdesc:afbfcb627a6ab1115bb02670e7ce61219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gauss-Legendre nodes and weights.  <br /></td></tr>
<tr class="separator:afbfcb627a6ab1115bb02670e7ce61219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcede29d3876b4a265f09a56db33085d" id="r_adcede29d3876b4a265f09a56db33085d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#adcede29d3876b4a265f09a56db33085d">leg_eval</a> (int n, double x)</td></tr>
<tr class="memdesc:adcede29d3876b4a265f09a56db33085d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate Legendre polynomial of degree n and its derivative.  <br /></td></tr>
<tr class="separator:adcede29d3876b4a265f09a56db33085d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767cf14e0aef568fefdb0386d255b510" id="r_a767cf14e0aef568fefdb0386d255b510"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a767cf14e0aef568fefdb0386d255b510">normsq</a> (nda::MemoryVector auto const &amp;v)</td></tr>
<tr class="separator:a767cf14e0aef568fefdb0386d255b510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c839b446002a589c9cc22534967b6" id="r_a1d0c839b446002a589c9cc22534967b6"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1d0c839b446002a589c9cc22534967b6"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a1d0c839b446002a589c9cc22534967b6">pivrgs</a> (T const &amp;a, double eps)</td></tr>
<tr class="memdesc:a1d0c839b446002a589c9cc22534967b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rank-revealing pivoted reorthogonalized Gram-Schmidt.  <br /></td></tr>
<tr class="separator:a1d0c839b446002a589c9cc22534967b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2becc5e7e7dfe9a59d7a45c309a2e47" id="r_ae2becc5e7e7dfe9a59d7a45c309a2e47"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ae2becc5e7e7dfe9a59d7a45c309a2e47"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ae2becc5e7e7dfe9a59d7a45c309a2e47">pivrgs_sym</a> (T const &amp;a, double eps)</td></tr>
<tr class="memdesc:ae2becc5e7e7dfe9a59d7a45c309a2e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrized rank-revealing pivoted reorthogonalized Gram-Schmidt.  <br /></td></tr>
<tr class="separator:ae2becc5e7e7dfe9a59d7a45c309a2e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64323a06309e2802fb97b93e3e24c2d" id="r_ad64323a06309e2802fb97b93e3e24c2d"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ad64323a06309e2802fb97b93e3e24c2d"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ad64323a06309e2802fb97b93e3e24c2d">pivrgs_sym</a> (T const &amp;a, int r)</td></tr>
<tr class="memdesc:ad64323a06309e2802fb97b93e3e24c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrized pivoted reorthogonalized Gram-Schmidt with specified rank.  <br /></td></tr>
<tr class="separator:ad64323a06309e2802fb97b93e3e24c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623b3f78817239e2d1653be8972cc5f1" id="r_a623b3f78817239e2d1653be8972cc5f1"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray Ta, nda::MemoryArray Tb, nda::Scalar Sa = nda::get_value_t&lt;Ta&gt;, nda::Scalar Sb = nda::get_value_t&lt;Tb&gt;, nda::Scalar S = std::common_type_t&lt;Sa, Sb&gt;&gt; </td></tr>
<tr class="memitem:a623b3f78817239e2d1653be8972cc5f1"><td class="memTemplItemLeft" align="right" valign="top">nda::array&lt; S, Ta::rank+Tb::rank - 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a623b3f78817239e2d1653be8972cc5f1">arraymult</a> (Ta const &amp;a, Tb const &amp;b)</td></tr>
<tr class="memdesc:a623b3f78817239e2d1653be8972cc5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract the last dimension of an array a with the first dimension of an array b.  <br /></td></tr>
<tr class="separator:a623b3f78817239e2d1653be8972cc5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93826a1ab8ed29d304e0194fefd4e19c" id="r_a93826a1ab8ed29d304e0194fefd4e19c"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a93826a1ab8ed29d304e0194fefd4e19c"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a93826a1ab8ed29d304e0194fefd4e19c">adapgl</a> (std::function&lt; nda::array&lt; S, 1 &gt;(nda::array&lt; double, 1 &gt;)&gt; f, double a, double b, double tol, nda::vector&lt; double &gt; xgl, nda::vector&lt; double &gt; wgl)</td></tr>
<tr class="memdesc:a93826a1ab8ed29d304e0194fefd4e19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick and dirty adaptive Gauss quadrature.  <br /></td></tr>
<tr class="separator:a93826a1ab8ed29d304e0194fefd4e19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afa13d278b5eff503e3399f445f84ab6d" id="r_afa13d278b5eff503e3399f445f84ab6d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecppdlr.html#afa13d278b5eff503e3399f445f84ab6da320d20930f8ff7ba461e55e30ea405c7">NONSYM</a> = false
, <a class="el" href="namespacecppdlr.html#afa13d278b5eff503e3399f445f84ab6da2926e3338e8cc759a75b8c9fac6f7d61">SYM</a> = true
 }</td></tr>
<tr class="separator:afa13d278b5eff503e3399f445f84ab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a7e33d9a03f4986937032c25ee7435" id="r_ad0a7e33d9a03f4986937032c25ee7435"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> { <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d">Boson</a> = 0
, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee">Fermion</a> = 1
 }</td></tr>
<tr class="separator:ad0a7e33d9a03f4986937032c25ee7435"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7b5392bb6f0a8155f1f19cab3bd042e9" id="r_a7b5392bb6f0a8155f1f19cab3bd042e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a7b5392bb6f0a8155f1f19cab3bd042e9">dcomplex</a> = std::complex&lt; double &gt;</td></tr>
<tr class="separator:a7b5392bb6f0a8155f1f19cab3bd042e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af914cc6f80f2a540846205c0a2ae1b73" id="r_af914cc6f80f2a540846205c0a2ae1b73"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T&gt; </td></tr>
<tr class="memitem:af914cc6f80f2a540846205c0a2ae1b73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#af914cc6f80f2a540846205c0a2ae1b73">make_real_t</a> = decltype(make_regular(nda::real(std::declval&lt; T &gt;())))</td></tr>
<tr class="memdesc:af914cc6f80f2a540846205c0a2ae1b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get real-valued type corresponding to type of given nda MemoryArray.  <br /></td></tr>
<tr class="separator:af914cc6f80f2a540846205c0a2ae1b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7426dd83d2c831f6ae3fa9b8e6172ad" id="r_af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T&gt; </td></tr>
<tr class="memitem:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#af7426dd83d2c831f6ae3fa9b8e6172ad">make_cplx_t</a> = decltype(make_regular(std::declval&lt; T &gt;() *1i))</td></tr>
<tr class="memdesc:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get complex-valued type corresponding to type of given nda MemoryArray.  <br /></td></tr>
<tr class="separator:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23dfec829ec6ed8deec469faeea3981" id="r_ac23dfec829ec6ed8deec469faeea3981"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S1, nda::Scalar S2&gt; </td></tr>
<tr class="memitem:ac23dfec829ec6ed8deec469faeea3981"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ac23dfec829ec6ed8deec469faeea3981">make_common_t</a> = typename <a class="el" href="structcppdlr_1_1make__common__helper.html">make_common_helper</a>&lt; T, S1, S2 &gt;::type</td></tr>
<tr class="separator:ac23dfec829ec6ed8deec469faeea3981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7b5392bb6f0a8155f1f19cab3bd042e9" name="a7b5392bb6f0a8155f1f19cab3bd042e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5392bb6f0a8155f1f19cab3bd042e9">&#9670;&#160;</a></span>dcomplex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::complex&lt; double &gt; <a class="el" href="namespacecppdlr.html#a7b5392bb6f0a8155f1f19cab3bd042e9">cppdlr::dcomplex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac23dfec829ec6ed8deec469faeea3981" name="ac23dfec829ec6ed8deec469faeea3981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23dfec829ec6ed8deec469faeea3981">&#9670;&#160;</a></span>make_common_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S1, nda::Scalar S2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppdlr.html#ac23dfec829ec6ed8deec469faeea3981">cppdlr::make_common_t</a> = typedef typename <a class="el" href="structcppdlr_1_1make__common__helper.html">make_common_helper</a>&lt;T, S1, S2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7426dd83d2c831f6ae3fa9b8e6172ad" name="af7426dd83d2c831f6ae3fa9b8e6172ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7426dd83d2c831f6ae3fa9b8e6172ad">&#9670;&#160;</a></span>make_cplx_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppdlr.html#af7426dd83d2c831f6ae3fa9b8e6172ad">cppdlr::make_cplx_t</a> = typedef decltype(make_regular(std::declval&lt;T&gt;() * 1i))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get complex-valued type corresponding to type of given nda MemoryArray. </p>

</div>
</div>
<a id="af914cc6f80f2a540846205c0a2ae1b73" name="af914cc6f80f2a540846205c0a2ae1b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af914cc6f80f2a540846205c0a2ae1b73">&#9670;&#160;</a></span>make_real_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppdlr.html#af914cc6f80f2a540846205c0a2ae1b73">cppdlr::make_real_t</a> = typedef decltype(make_regular(nda::real(std::declval&lt;T&gt;())))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get real-valued type corresponding to type of given nda MemoryArray. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afa13d278b5eff503e3399f445f84ab6d" name="afa13d278b5eff503e3399f445f84ab6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa13d278b5eff503e3399f445f84ab6d">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Option for unsymmetrized or symmetrized DLR </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afa13d278b5eff503e3399f445f84ab6da320d20930f8ff7ba461e55e30ea405c7" name="afa13d278b5eff503e3399f445f84ab6da320d20930f8ff7ba461e55e30ea405c7"></a>NONSYM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afa13d278b5eff503e3399f445f84ab6da2926e3338e8cc759a75b8c9fac6f7d61" name="afa13d278b5eff503e3399f445f84ab6da2926e3338e8cc759a75b8c9fac6f7d61"></a>SYM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad0a7e33d9a03f4986937032c25ee7435" name="ad0a7e33d9a03f4986937032c25ee7435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a7e33d9a03f4986937032c25ee7435">&#9670;&#160;</a></span>statistic_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">cppdlr::statistic_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Particle Statistic: Boson or Fermion </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d" name="ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d"></a>Boson&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee" name="ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee"></a>Fermion&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a791b659aaebe1e52cf12edb3b089b224" name="a791b659aaebe1e52cf12edb3b089b224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b659aaebe1e52cf12edb3b089b224">&#9670;&#160;</a></span>abs2rel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::abs2rel </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_abs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from relative to absolute time format.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Vector of points on [0,1] in relative time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in absolute time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Converting a point from relative to absolute time format will, in general, result in a loss of relative accuracy in the location of the point if the point is close to t = 1. For example, in three-digit arithmetic, the point t = 0.999111 could be stored in relative format as t^* = -0.889e-3, but only as t = 0.999 in absolute format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation.   </dd></dl>

</div>
</div>
<a id="a103a8aae4c8af512d2682d381a676561" name="a103a8aae4c8af512d2682d381a676561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103a8aae4c8af512d2682d381a676561">&#9670;&#160;</a></span>abs2rel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::abs2rel </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t_abs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from absolute to relative time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_abs</td><td>Vector of points on [0,1] in absolute time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in relative time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>cppdlr uses the relative time format to describe imaginary time points. Therefore, if you wish to specify an imaginary time point in the standard absolute time format, for example to specify a point at which to evaluate a DLR expansion, you must first convert the point to the relative time format using this function. However, in order to maintain full relative precision in all calculations, you must conform to the cppdlr standard and specify point in the relative time format from the beginning. On the other hand, in most cases only a mild loss of accuracy will result from beginning with the absolute format and then converting to the relative format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. </dd></dl>

</div>
</div>
<a id="a93826a1ab8ed29d304e0194fefd4e19c" name="a93826a1ab8ed29d304e0194fefd4e19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93826a1ab8ed29d304e0194fefd4e19c">&#9670;&#160;</a></span>adapgl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S cppdlr::adapgl </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; nda::array&lt; S, 1 &gt;(nda::array&lt; double, 1 &gt;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>xgl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>wgl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quick and dirty adaptive Gauss quadrature. </p>
<p>This function implements adaptive Gauss-Legendre quadrature with local error estimation only, using a stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function to be integrated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Lower integration limit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Upper integration limit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Absolute error tolerance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xgl</td><td>Gauss-Legendre nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wgl</td><td>Gauss-Legendre weights</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral of <code>f</code> from <code>a</code> to <code>b</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a quick and dirty adaptive integration function, which tries to achieve an error tolerance <code>tol</code> but doesn't guarantee it. A more robust implementation would use global error estimation. Nevertheless, this works quite well most of the time. </dd></dl>

</div>
</div>
<a id="a623b3f78817239e2d1653be8972cc5f1" name="a623b3f78817239e2d1653be8972cc5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623b3f78817239e2d1653be8972cc5f1">&#9670;&#160;</a></span>arraymult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray Ta, nda::MemoryArray Tb, nda::Scalar Sa = nda::get_value_t&lt;Ta&gt;, nda::Scalar Sb = nda::get_value_t&lt;Tb&gt;, nda::Scalar S = std::common_type_t&lt;Sa, Sb&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">nda::array&lt; S, Ta::rank+Tb::rank - 2 &gt; cppdlr::arraymult </td>
          <td>(</td>
          <td class="paramtype">Ta const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tb const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contract the last dimension of an array a with the first dimension of an array b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An array/matrix/vector or array/matrix/vector view of rank at least 2 </td></tr>
    <tr><td class="paramname">b</td><td>An array/matrix/vector or array/matrix/vector view of rank at least 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contraction of the inner dimensions of <code>a</code> and <code>b</code> </dd></dl>

</div>
</div>
<a id="aa355c3aaf829296d7e5869eff98fedd1" name="aa355c3aaf829296d7e5869eff98fedd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa355c3aaf829296d7e5869eff98fedd1">&#9670;&#160;</a></span>baryinterp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::baryinterp </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xeval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Barycentric Lagrange interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Interpolation nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Barycentric interpolation weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function values at interpolation nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xeval</td><td>Point at which to evaluate interpolated function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated function value at xeval </dd></dl>

</div>
</div>
<a id="ace84f47b6cc94a562dfd5207791c27b0" name="ace84f47b6cc94a562dfd5207791c27b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace84f47b6cc94a562dfd5207791c27b0">&#9670;&#160;</a></span>build_dlr_rf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_dlr_rf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct DLR basis by obtaining DLR frequencies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>DLR cutoff parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>Accuracy of DLR basis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLR frequencies</dd></dl>
<dl class="section note"><dt>Note</dt><dd>With this signature, the DLR frequencies are unsymmetrized. </dd></dl>

</div>
</div>
<a id="a07f27d33c07f08031768f0844d14724e" name="a07f27d33c07f08031768f0844d14724e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f27d33c07f08031768f0844d14724e">&#9670;&#160;</a></span>build_dlr_rf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_dlr_rf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetrize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct DLR basis by obtaining DLR frequencies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>DLR cutoff parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>Accuracy of DLR basis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmetrize</td><td>NONSYM or false for non-symmetrized DLR frequencies, SYM or true for symmetrized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLR frequencies </dd></dl>

</div>
</div>
<a id="afa672c293b0b90ab5045fbb091a1ed57" name="afa672c293b0b90ab5045fbb091a1ed57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa672c293b0b90ab5045fbb091a1ed57">&#9670;&#160;</a></span>build_it_fine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt; cppdlr::build_it_fine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;&#160;</td>
          <td class="paramname"><em>fine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get fine composite Legendre grid in imaginary time and corresponding square root quadrature weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fine</td><td>Fine grid parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple containing fine imaginary time grid and corresponding square root quadrature weights</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Fine imaginary time grid is given in relative format </dd></dl>

</div>
</div>
<a id="a988f80420d11cd80ac3803bd3bd429c0" name="a988f80420d11cd80ac3803bd3bd429c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988f80420d11cd80ac3803bd3bd429c0">&#9670;&#160;</a></span>build_k_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt; <a class="el" href="namespacecppdlr.html#a7b5392bb6f0a8155f1f19cab3bd042e9">dcomplex</a> &gt; cppdlr::build_k_if </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary frequency discretization of analytic continuation kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmax</td><td>Imaginary frequency cutoff </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle Statistic: Boson or Fermion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="ab471fd1439bcd11be6bc10de9703138a" name="ab471fd1439bcd11be6bc10de9703138a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab471fd1439bcd11be6bc10de9703138a">&#9670;&#160;</a></span>build_k_it() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid   </dd></dl>

</div>
</div>
<a id="ad4b931a8f12802eee8e74307c655ca85" name="ad4b931a8f12802eee8e74307c655ca85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b931a8f12802eee8e74307c655ca85">&#9670;&#160;</a></span>build_k_it() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid   </dd></dl>

</div>
</div>
<a id="a38c50dbbe81c1821676393f8584fb3f6" name="a38c50dbbe81c1821676393f8584fb3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c50dbbe81c1821676393f8584fb3f6">&#9670;&#160;</a></span>build_k_it() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="a45377bb09b54d66487cf379b1a6037de" name="a45377bb09b54d66487cf379b1a6037de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45377bb09b54d66487cf379b1a6037de">&#9670;&#160;</a></span>build_k_it() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel with L^2 weighting.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Square root quadrature weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid   </dd></dl>

</div>
</div>
<a id="ad6df2a0cc73644667ba77bf562a9e140" name="ad6df2a0cc73644667ba77bf562a9e140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6df2a0cc73644667ba77bf562a9e140">&#9670;&#160;</a></span>build_k_it() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel with L^2 weighting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Square root quadrature weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="a83cde5c4ed014eb53f7c16392a41733e" name="a83cde5c4ed014eb53f7c16392a41733e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cde5c4ed014eb53f7c16392a41733e">&#9670;&#160;</a></span>build_rf_fine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_rf_fine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;&#160;</td>
          <td class="paramname"><em>fine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build fine composite Chebyshev grid in real frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fine</td><td>Fine grid parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Fine real frequency grid </dd></dl>

</div>
</div>
<a id="a2d46bf12944fe36c90343df67e2d783b" name="a2d46bf12944fe36c90343df67e2d783b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d46bf12944fe36c90343df67e2d783b">&#9670;&#160;</a></span>eqptsrel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::eqptsrel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get grid of equispaced points on [0,1] in relative time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of equispaced points on [0,1] in relative time format </dd></dl>

</div>
</div>
<a id="a4b753b1a7de53aff215a230206908e6d" name="a4b753b1a7de53aff215a230206908e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b753b1a7de53aff215a230206908e6d">&#9670;&#160;</a></span>free_gf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ht &gt; <br />
requires (std::floating_point&lt;Ht&gt; || nda::MemoryMatrix&lt;Ht&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto cppdlr::free_gf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;&#160;</td>
          <td class="paramname"><em>itops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ht const &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>time_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute free-particle imaginary time Green's function for a given Hamiltonian. </p>
<p>The Green's function is computed by diagonalizing the Hamiltonian, and is returned by its values at the DLR imaginary time nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td><a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hamiltonian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY) or time-ordered (true or TIME_ORDERED) Dyson equation, which changes free Green's function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Green's function at DLR imaginary time nodes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Hamiltonian must either be a symmetric matrix, a Hermitian matrix, or a real scalar. </dd></dl>

</div>
</div>
<a id="a02424caf43ace0c3330b2fa03f706400" name="a02424caf43ace0c3330b2fa03f706400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02424caf43ace0c3330b2fa03f706400">&#9670;&#160;</a></span>free_gf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ht &gt; <br />
requires (std::floating_point&lt;Ht&gt; || nda::MemoryMatrix&lt;Ht&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto cppdlr::free_gf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;&#160;</td>
          <td class="paramname"><em>itops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ht const &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>time_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute free-particle imaginary time Green's function for a given Hamiltonian. </p>
<p>The Green's function is computed by diagonalizing the Hamiltonian, and is returned by its values at the DLR imaginary time nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td><a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hamiltonian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>Chemical potential </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY, default) or time-ordered (true or TIME_ORDERED) Dyson equation, which changes free Green's function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Green's function at DLR imaginary time nodes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Hamiltonian must either be a symmetric matrix, a Hermitian matrix, or a real scalar. </dd></dl>

</div>
</div>
<a id="afbfcb627a6ab1115bb02670e7ce61219" name="afbfcb627a6ab1115bb02670e7ce61219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfcb627a6ab1115bb02670e7ce61219">&#9670;&#160;</a></span>gaussquad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt; cppdlr::gaussquad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gauss-Legendre nodes and weights. </p>
<p>Uses Newton iteration to obtain the Gauss-Legendre nodes and weights</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of nodes and weights </dd></dl>

</div>
</div>
<a id="a48fb848c5a66d6141ad240d2e749aec9" name="a48fb848c5a66d6141ad240d2e749aec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fb848c5a66d6141ad240d2e749aec9">&#9670;&#160;</a></span>geterr_k_it()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, double &gt; cppdlr::geterr_k_it </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::matrix_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>kmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get error of fine composite Chebyshev discretization of analytic continuation kernel in imaginary time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fine</td><td>Fine grid parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kmat</td><td>Discretization of analytic continuation kernel on given grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error of given fine discretization of analytic continuation kernel in imaginary time and real frequency</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Error is given as an estimate of the maximum absolute value of the difference between the given discretization and the exact analytic continuation kernel</dd>
<dd>
<code>kmat</code> should be computed using the function get_kfine with composite Chebyshev grids produced by get_omfine and get_tfine </dd></dl>

</div>
</div>
<a id="af8f77e12b089b5ddb5b5b3cda18cf623" name="af8f77e12b089b5ddb5b5b3cda18cf623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f77e12b089b5ddb5b5b3cda18cf623">&#9670;&#160;</a></span>k_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Imaginary frequency index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle Statistic: Boson or Fermion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(i nu_n, om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel using dimensionless variables is K(i nu_n, om) = 1 / (i nu_n - om) with i nu_n = (2n+1) * i * pi (fermionic case) or i nu_n = 2n * i * pi (bosonic case). </dd></dl>

</div>
</div>
<a id="a672098c598c55c8f9da60cd194a741ea" name="a672098c598c55c8f9da60cd194a741ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672098c598c55c8f9da60cd194a741ea">&#9670;&#160;</a></span>k_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary frequency for a given inverse temperature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Imaginary frequency index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle Statistic: Boson or Fermion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(i nu_n, om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel at a given inverse temperature beta is K(i nu_n, om) = 1 / (i nu_n - om) with i nu_n = (2n+1) * i * pi / beta (fermionic case) or i nu_n = 2n * i * pi / beta (bosonic case). </dd></dl>

</div>
</div>
<a id="ab73f52d9e0209e584d1210d419f39f8c" name="ab73f52d9e0209e584d1210d419f39f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73f52d9e0209e584d1210d419f39f8c">&#9670;&#160;</a></span>k_if_boson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if_boson </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate bosonic analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Imaginary frequency index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(i nu_n, om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the bosonic analytic continuation kernel using dimensionless variables is K(i nu_n, om) = 1 / (i nu_n - om) with i nu_n = 2n * i * pi. </dd></dl>

</div>
</div>
<a id="a66270b210c46b39737f361467f645be7" name="a66270b210c46b39737f361467f645be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66270b210c46b39737f361467f645be7">&#9670;&#160;</a></span>k_if_fermion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if_fermion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate fermionic analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Imaginary frequency index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(i nu_n, om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the fermionic analytic continuation kernel using dimensionless variables is K(i nu_n, om) = 1 / (i nu_n - om) with i nu_n = (2n+1) * i * pi. </dd></dl>

</div>
</div>
<a id="afc9726e02898098dfff8448f02f5b3c6" name="afc9726e02898098dfff8448f02f5b3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9726e02898098dfff8448f02f5b3c6">&#9670;&#160;</a></span>k_it() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::k_it </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary time (relative time format) using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time value (relative format) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(t,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel using dimensionless variables is K(t,om) = -exp(-t * om)/(1 + exp(-om)). </dd></dl>

</div>
</div>
<a id="a3cfc4afda9cacac00e93425fe9d45a93" name="a3cfc4afda9cacac00e93425fe9d45a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfc4afda9cacac00e93425fe9d45a93">&#9670;&#160;</a></span>k_it() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::k_it </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary time (relative time format) for a given inverse temperature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time value (relative format) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(t,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel at a given inverse temperature beta is K(t,om) = -exp(-t*om)/(1+exp(-beta * om)). </dd></dl>

</div>
</div>
<a id="a7dfaf907221eb1768418258421af703f" name="a7dfaf907221eb1768418258421af703f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfaf907221eb1768418258421af703f">&#9670;&#160;</a></span>k_it_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::k_it_abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary time (absolute time format) using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time value (absolute format) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(t,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel using dimensionless variables is K(t,om) = -exp(-t * om)/(1 + exp(-om)). </dd></dl>

</div>
</div>
<a id="adcede29d3876b4a265f09a56db33085d" name="adcede29d3876b4a265f09a56db33085d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcede29d3876b4a265f09a56db33085d">&#9670;&#160;</a></span>leg_eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, double &gt; cppdlr::leg_eval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate Legendre polynomial of degree n and its derivative. </p>
<p>Uses Legendre three-term recurrence</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Degree of polynomial Pn(x) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Point at which to evaluate polynomial</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of polynomial value Pn(x) and derivative Pn'(x) </dd></dl>

</div>
</div>
<a id="a767cf14e0aef568fefdb0386d255b510" name="a767cf14e0aef568fefdb0386d255b510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767cf14e0aef568fefdb0386d255b510">&#9670;&#160;</a></span>normsq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::normsq </td>
          <td>(</td>
          <td class="paramtype">nda::MemoryVector auto const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the squared norm of a vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x The squared norm of the vector </dd></dl>

</div>
</div>
<a id="a1d0c839b446002a589c9cc22534967b6" name="a1d0c839b446002a589c9cc22534967b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0c839b446002a589c9cc22534967b6">&#9670;&#160;</a></span>pivrgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt; cppdlr::pivrgs </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rank-revealing pivoted reorthogonalized Gram-Schmidt. </p>
<p>Determine the epsilon-rank of a matrix and return an orthogonal basis of its epsilon-row space.</p>
<p>This is a translation of the Fortran subroutine "qrdgrm" by V. Rokhlin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Matrix to be orthogonalized </td></tr>
    <tr><td class="paramname">eps</td><td>Rank cutoff tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (1) matrix whose rows form orthogonal basis of row space of <code>a</code> to <code>eps</code> tolerance, (2) vector with entry n given by the squared l2 norm of the orthogonal complement of nth selected row with respect to subspace spanned by first n-1 selected rows, (3) vector of pivots </dd></dl>

</div>
</div>
<a id="ae2becc5e7e7dfe9a59d7a45c309a2e47" name="ae2becc5e7e7dfe9a59d7a45c309a2e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2becc5e7e7dfe9a59d7a45c309a2e47">&#9670;&#160;</a></span>pivrgs_sym() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt; cppdlr::pivrgs_sym </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrized rank-revealing pivoted reorthogonalized Gram-Schmidt. </p>
<p>Determine the epsilon-rank of a matrix and return an orthogonal basis of its epsilon-row space, enforcing symmetrization of pivots.</p>
<p>This is a translation of the Fortran subroutine "qrdgrm" by V. Rokhlin, with symmetrization added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Matrix to be orthogonalized </td></tr>
    <tr><td class="paramname">eps</td><td>Rank cutoff tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (1) matrix whose rows form orthogonal basis of row space of <code>a</code> to <code>eps</code> tolerance, (2) vector with entry n given by the squared l2 norm of the orthogonal complement of nth selected row with respect to subspace spanned by first n-1 selected rows, (3) vector of pivots</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The symmetrization condition is that if A(i,:), the ith row of A, is selected as a pivot, then A(m-i-1,:) is also selected as a pivot. Here, m is the row dimension of A, and A is zero-indexed. m must be even. </dd></dl>

</div>
</div>
<a id="ad64323a06309e2802fb97b93e3e24c2d" name="ad64323a06309e2802fb97b93e3e24c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64323a06309e2802fb97b93e3e24c2d">&#9670;&#160;</a></span>pivrgs_sym() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt; cppdlr::pivrgs_sym </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrized pivoted reorthogonalized Gram-Schmidt with specified rank. </p>
<p>Return the leading r vectors of an orthogonal basis of the row space, enforcing symmetrization of pivots.</p>
<p>This is a translation of the Fortran subroutine "qrdgrm" by V. Rokhlin, with symmetrization added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Matrix to be orthogonalized </td></tr>
    <tr><td class="paramname">r</td><td>Rank cutoff</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (1) matrix whose rows are leading <code>r</code> vectors in orthogonal basis of row space of <code>a</code>, (2) vector with entry n given by the squared l2 norm of the orthogonal complement of nth selected row with respect to subspace spanned by first n-1 selected rows, (3) vector of pivots</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The symmetrization condition is that if A(i,:), the ith row of A, is selected as a pivot, then A(m-i-1,:) is also selected as a pivot. Here, m is the row dimension of A, and A is zero-indexed. A can have an odd number of rows if and only if <code>r</code> is odd, and in this case the middle row (index (m-1)/2) of A is automatically selected as a pivot. </dd></dl>

</div>
</div>
<a id="a373b198ea4a2d60eb80052dc0d4ae229" name="a373b198ea4a2d60eb80052dc0d4ae229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373b198ea4a2d60eb80052dc0d4ae229">&#9670;&#160;</a></span>rel2abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::rel2abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from relative to absolute time format.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Vector of points on [0,1] in relative time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in absolute time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Converting a point from relative to absolute time format will, in general, result in a loss of relative accuracy in the location of the point if the point is close to t = 1. For example, in three-digit arithmetic, the point t = 0.999111 could be stored in relative format as t^* = -0.889e-3, but only as t = 0.999 in absolute format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation.   </dd></dl>

</div>
</div>
<a id="a3b1ccba6393dfc517757677a13ad2553" name="a3b1ccba6393dfc517757677a13ad2553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1ccba6393dfc517757677a13ad2553">&#9670;&#160;</a></span>rel2abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::rel2abs </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from relative to absolute time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Vector of points on [0,1] in relative time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in absolute time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Converting a point from relative to absolute time format will, in general, result in a loss of relative accuracy in the location of the point if the point is close to t = 1. For example, in three-digit arithmetic, the point t = 0.999111 could be stored in relative format as t^* = -0.889e-3, but only as t = 0.999 in absolute format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
