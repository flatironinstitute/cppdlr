<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppdlr: cppdlr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cppdlr
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Imaginary time calculations using the discrete Lehmann representation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cppdlr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class containing parameters for fine composite Chebyshev grid discretizations of imaginary time and frequency.  <a href="classcppdlr_1_1fineparams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imfreq__ops.html">imfreq_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class responsible for all DLR imaginary frequency operations, including building imaginary frequency grid and transformations.  <a href="classcppdlr_1_1imfreq__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations.  <a href="classcppdlr_1_1imtime__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1barycheb.html">barycheb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1baryleg.html">baryleg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppdlr_1_1make__common__helper.html">make_common_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of given nda MemoryArray with scalar value type replaced by common type of two given types (real if both are real, complex otherwise)  <a href="structcppdlr_1_1make__common__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83cde5c4ed014eb53f7c16392a41733e"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a83cde5c4ed014eb53f7c16392a41733e">build_rf_fine</a> (<a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;fine)</td></tr>
<tr class="memdesc:a83cde5c4ed014eb53f7c16392a41733e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build fine composite Chebyshev grid in real frequency.  <a href="namespacecppdlr.html#a83cde5c4ed014eb53f7c16392a41733e">More...</a><br /></td></tr>
<tr class="separator:a83cde5c4ed014eb53f7c16392a41733e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa672c293b0b90ab5045fbb091a1ed57"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#afa672c293b0b90ab5045fbb091a1ed57">build_it_fine</a> (<a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;fine)</td></tr>
<tr class="memdesc:afa672c293b0b90ab5045fbb091a1ed57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get fine composite Legendre grid in imaginary time and corresponding square root quadrature weights.  <a href="namespacecppdlr.html#afa672c293b0b90ab5045fbb091a1ed57">More...</a><br /></td></tr>
<tr class="separator:afa672c293b0b90ab5045fbb091a1ed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c50dbbe81c1821676393f8584fb3f6"><td class="memItemLeft" align="right" valign="top">nda::matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a38c50dbbe81c1821676393f8584fb3f6">build_k_it</a> (nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; om)</td></tr>
<tr class="memdesc:a38c50dbbe81c1821676393f8584fb3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel.  <a href="namespacecppdlr.html#a38c50dbbe81c1821676393f8584fb3f6">More...</a><br /></td></tr>
<tr class="separator:a38c50dbbe81c1821676393f8584fb3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6df2a0cc73644667ba77bf562a9e140"><td class="memItemLeft" align="right" valign="top">nda::matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ad6df2a0cc73644667ba77bf562a9e140">build_k_it</a> (nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; w, nda::vector_const_view&lt; double &gt; om)</td></tr>
<tr class="memdesc:ad6df2a0cc73644667ba77bf562a9e140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel with L^2 weighting.  <a href="namespacecppdlr.html#ad6df2a0cc73644667ba77bf562a9e140">More...</a><br /></td></tr>
<tr class="separator:ad6df2a0cc73644667ba77bf562a9e140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab471fd1439bcd11be6bc10de9703138a"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ab471fd1439bcd11be6bc10de9703138a">build_k_it</a> (double t, nda::vector_const_view&lt; double &gt; om)</td></tr>
<tr class="memdesc:ab471fd1439bcd11be6bc10de9703138a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel.  <a href="namespacecppdlr.html#ab471fd1439bcd11be6bc10de9703138a">More...</a><br /></td></tr>
<tr class="separator:ab471fd1439bcd11be6bc10de9703138a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b931a8f12802eee8e74307c655ca85"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ad4b931a8f12802eee8e74307c655ca85">build_k_it</a> (nda::vector_const_view&lt; double &gt; t, double om)</td></tr>
<tr class="memdesc:ad4b931a8f12802eee8e74307c655ca85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel.  <a href="namespacecppdlr.html#ad4b931a8f12802eee8e74307c655ca85">More...</a><br /></td></tr>
<tr class="separator:ad4b931a8f12802eee8e74307c655ca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45377bb09b54d66487cf379b1a6037de"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a45377bb09b54d66487cf379b1a6037de">build_k_it</a> (nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; w, double om)</td></tr>
<tr class="memdesc:a45377bb09b54d66487cf379b1a6037de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel with L^2 weighting.  <a href="namespacecppdlr.html#a45377bb09b54d66487cf379b1a6037de">More...</a><br /></td></tr>
<tr class="separator:a45377bb09b54d66487cf379b1a6037de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb848c5a66d6141ad240d2e749aec9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a48fb848c5a66d6141ad240d2e749aec9">geterr_k_it</a> (<a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;fine, nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; om, nda::matrix_const_view&lt; double &gt; kmat)</td></tr>
<tr class="memdesc:a48fb848c5a66d6141ad240d2e749aec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get error of fine composite Chebyshev discretization of analytic continuation kernel in imaginary time.  <a href="namespacecppdlr.html#a48fb848c5a66d6141ad240d2e749aec9">More...</a><br /></td></tr>
<tr class="separator:a48fb848c5a66d6141ad240d2e749aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988f80420d11cd80ac3803bd3bd429c0"><td class="memItemLeft" align="right" valign="top">nda::matrix&lt; dcomplex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a988f80420d11cd80ac3803bd3bd429c0">build_k_if</a> (int nmax, nda::vector_const_view&lt; double &gt; om, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic)</td></tr>
<tr class="memdesc:a988f80420d11cd80ac3803bd3bd429c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary frequency discretization of analytic continuation kernel.  <a href="namespacecppdlr.html#a988f80420d11cd80ac3803bd3bd429c0">More...</a><br /></td></tr>
<tr class="separator:a988f80420d11cd80ac3803bd3bd429c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134a65b6f951a80cb99e41d52d89f0ed"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a134a65b6f951a80cb99e41d52d89f0ed">build_dlr_rf</a> (double lambda, double eps, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic, bool symmetrize)</td></tr>
<tr class="memdesc:a134a65b6f951a80cb99e41d52d89f0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct DLR basis by obtaining DLR frequencies.  <a href="namespacecppdlr.html#a134a65b6f951a80cb99e41d52d89f0ed">More...</a><br /></td></tr>
<tr class="separator:a134a65b6f951a80cb99e41d52d89f0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace84f47b6cc94a562dfd5207791c27b0"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ace84f47b6cc94a562dfd5207791c27b0">build_dlr_rf</a> (double lambda, double eps)</td></tr>
<tr class="memdesc:ace84f47b6cc94a562dfd5207791c27b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct DLR basis by obtaining DLR frequencies.  <a href="namespacecppdlr.html#ace84f47b6cc94a562dfd5207791c27b0">More...</a><br /></td></tr>
<tr class="separator:ace84f47b6cc94a562dfd5207791c27b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd50fc5abb306456b4b2710bea369c1a"><td class="memTemplParams" colspan="2">template&lt;typename Ht , nda::Scalar Sh = std::conditional_t&lt;std::floating_point&lt;Ht&gt;, Ht, get_value_t&lt;Ht&gt;&gt;&gt; </td></tr>
<tr class="memitem:acd50fc5abb306456b4b2710bea369c1a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#acd50fc5abb306456b4b2710bea369c1a">requires</a> (std::floating_point&lt; Ht &gt;||nda::MemoryMatrix&lt; Ht &gt;) class <a class="el" href="classdyson__it.html">dyson_it</a></td></tr>
<tr class="separator:acd50fc5abb306456b4b2710bea369c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a73f63b1734b37ef26f7edf1ca0034"><td class="memTemplParams" colspan="2">template&lt;typename Ht &gt; </td></tr>
<tr class="memitem:a59a73f63b1734b37ef26f7edf1ca0034"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a59a73f63b1734b37ef26f7edf1ca0034">requires</a> (std::floating_point&lt; Ht &gt;||nda::MemoryMatrix&lt; Ht &gt;) auto free_gf(double beta</td></tr>
<tr class="memdesc:a59a73f63b1734b37ef26f7edf1ca0034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute free-particle imaginary time Green's function for a given Hamiltonian.  <a href="namespacecppdlr.html#a59a73f63b1734b37ef26f7edf1ca0034">More...</a><br /></td></tr>
<tr class="separator:a59a73f63b1734b37ef26f7edf1ca0034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9726e02898098dfff8448f02f5b3c6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#afc9726e02898098dfff8448f02f5b3c6">k_it</a> (double t, double om)</td></tr>
<tr class="memdesc:afc9726e02898098dfff8448f02f5b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary time (relative time format) using dimensionless variables (beta = 1)  <a href="namespacecppdlr.html#afc9726e02898098dfff8448f02f5b3c6">More...</a><br /></td></tr>
<tr class="separator:afc9726e02898098dfff8448f02f5b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfc4afda9cacac00e93425fe9d45a93"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a3cfc4afda9cacac00e93425fe9d45a93">k_it</a> (double t, double om, double beta)</td></tr>
<tr class="memdesc:a3cfc4afda9cacac00e93425fe9d45a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary time (relative time format) for a given inverse temperature.  <a href="namespacecppdlr.html#a3cfc4afda9cacac00e93425fe9d45a93">More...</a><br /></td></tr>
<tr class="separator:a3cfc4afda9cacac00e93425fe9d45a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfaf907221eb1768418258421af703f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a7dfaf907221eb1768418258421af703f">k_it_abs</a> (double t, double om)</td></tr>
<tr class="memdesc:a7dfaf907221eb1768418258421af703f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary time (absolute time format) using dimensionless variables (beta = 1)  <a href="namespacecppdlr.html#a7dfaf907221eb1768418258421af703f">More...</a><br /></td></tr>
<tr class="separator:a7dfaf907221eb1768418258421af703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfc2f4ecdd39b95d4419a4be35909a4"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#abbfc2f4ecdd39b95d4419a4be35909a4">k_if_fermion</a> (int n, double om)</td></tr>
<tr class="separator:abbfc2f4ecdd39b95d4419a4be35909a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003438d56c2ca900d2f08af9f2ab424d"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a003438d56c2ca900d2f08af9f2ab424d">k_if_boson</a> (int n, double om)</td></tr>
<tr class="separator:a003438d56c2ca900d2f08af9f2ab424d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f77e12b089b5ddb5b5b3cda18cf623"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#af8f77e12b089b5ddb5b5b3cda18cf623">k_if</a> (int n, double om, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic)</td></tr>
<tr class="memdesc:af8f77e12b089b5ddb5b5b3cda18cf623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1)  <a href="namespacecppdlr.html#af8f77e12b089b5ddb5b5b3cda18cf623">More...</a><br /></td></tr>
<tr class="separator:af8f77e12b089b5ddb5b5b3cda18cf623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672098c598c55c8f9da60cd194a741ea"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a672098c598c55c8f9da60cd194a741ea">k_if</a> (int n, double om, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic, double beta)</td></tr>
<tr class="memdesc:a672098c598c55c8f9da60cd194a741ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary frequency for a given inverse temperature.  <a href="namespacecppdlr.html#a672098c598c55c8f9da60cd194a741ea">More...</a><br /></td></tr>
<tr class="separator:a672098c598c55c8f9da60cd194a741ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa355c3aaf829296d7e5869eff98fedd1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#aa355c3aaf829296d7e5869eff98fedd1">baryinterp</a> (nda::vector_const_view&lt; double &gt; x, nda::vector_const_view&lt; double &gt; w, nda::vector_const_view&lt; double &gt; f, double xeval)</td></tr>
<tr class="memdesc:aa355c3aaf829296d7e5869eff98fedd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Barycentric Lagrange interpolation.  <a href="namespacecppdlr.html#aa355c3aaf829296d7e5869eff98fedd1">More...</a><br /></td></tr>
<tr class="separator:aa355c3aaf829296d7e5869eff98fedd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d46bf12944fe36c90343df67e2d783b"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a2d46bf12944fe36c90343df67e2d783b">eqptsrel</a> (int n)</td></tr>
<tr class="memdesc:a2d46bf12944fe36c90343df67e2d783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get grid of equispaced points on [0,1] in relative time format.  <a href="namespacecppdlr.html#a2d46bf12944fe36c90343df67e2d783b">More...</a><br /></td></tr>
<tr class="separator:a2d46bf12944fe36c90343df67e2d783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ccba6393dfc517757677a13ad2553"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a3b1ccba6393dfc517757677a13ad2553">rel2abs</a> (nda::vector_const_view&lt; double &gt; t)</td></tr>
<tr class="memdesc:a3b1ccba6393dfc517757677a13ad2553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from relative to absolute time format.  <a href="namespacecppdlr.html#a3b1ccba6393dfc517757677a13ad2553">More...</a><br /></td></tr>
<tr class="separator:a3b1ccba6393dfc517757677a13ad2553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373b198ea4a2d60eb80052dc0d4ae229"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a373b198ea4a2d60eb80052dc0d4ae229">rel2abs</a> (double t)</td></tr>
<tr class="memdesc:a373b198ea4a2d60eb80052dc0d4ae229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from relative to absolute time format.  <a href="namespacecppdlr.html#a373b198ea4a2d60eb80052dc0d4ae229">More...</a><br /></td></tr>
<tr class="separator:a373b198ea4a2d60eb80052dc0d4ae229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103a8aae4c8af512d2682d381a676561"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a103a8aae4c8af512d2682d381a676561">abs2rel</a> (nda::vector_const_view&lt; double &gt; t_abs)</td></tr>
<tr class="memdesc:a103a8aae4c8af512d2682d381a676561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from absolute to relative time format.  <a href="namespacecppdlr.html#a103a8aae4c8af512d2682d381a676561">More...</a><br /></td></tr>
<tr class="separator:a103a8aae4c8af512d2682d381a676561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b659aaebe1e52cf12edb3b089b224"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a791b659aaebe1e52cf12edb3b089b224">abs2rel</a> (double t_abs)</td></tr>
<tr class="memdesc:a791b659aaebe1e52cf12edb3b089b224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from relative to absolute time format.  <a href="namespacecppdlr.html#a791b659aaebe1e52cf12edb3b089b224">More...</a><br /></td></tr>
<tr class="separator:a791b659aaebe1e52cf12edb3b089b224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfcb627a6ab1115bb02670e7ce61219"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#afbfcb627a6ab1115bb02670e7ce61219">gaussquad</a> (int n)</td></tr>
<tr class="memdesc:afbfcb627a6ab1115bb02670e7ce61219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gauss-Legendre nodes and weights.  <a href="namespacecppdlr.html#afbfcb627a6ab1115bb02670e7ce61219">More...</a><br /></td></tr>
<tr class="separator:afbfcb627a6ab1115bb02670e7ce61219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcede29d3876b4a265f09a56db33085d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#adcede29d3876b4a265f09a56db33085d">leg_eval</a> (int n, double x)</td></tr>
<tr class="memdesc:adcede29d3876b4a265f09a56db33085d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate Legendre polynomial of degree n and its derivative.  <a href="namespacecppdlr.html#adcede29d3876b4a265f09a56db33085d">More...</a><br /></td></tr>
<tr class="separator:adcede29d3876b4a265f09a56db33085d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02cc711894b431452f59f40e6f17dac"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ac02cc711894b431452f59f40e6f17dac"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ac02cc711894b431452f59f40e6f17dac">pivrgs</a> (T const &amp;a, double eps)</td></tr>
<tr class="memdesc:ac02cc711894b431452f59f40e6f17dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rank-revealing pivoted reorthogonalized Gram-Schmidt.  <a href="namespacecppdlr.html#ac02cc711894b431452f59f40e6f17dac">More...</a><br /></td></tr>
<tr class="separator:ac02cc711894b431452f59f40e6f17dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65790598f458616dbc7fc84ab3cfe02c"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a65790598f458616dbc7fc84ab3cfe02c"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a65790598f458616dbc7fc84ab3cfe02c">pivrgs_sym</a> (T const &amp;a, double eps)</td></tr>
<tr class="memdesc:a65790598f458616dbc7fc84ab3cfe02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrized rank-revealing pivoted reorthogonalized Gram-Schmidt.  <a href="namespacecppdlr.html#a65790598f458616dbc7fc84ab3cfe02c">More...</a><br /></td></tr>
<tr class="separator:a65790598f458616dbc7fc84ab3cfe02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cd86b43bae8fd0272a4f764bcd163f"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = get_value_t&lt;T&gt;, nda::MemoryVector V&gt; </td></tr>
<tr class="memitem:a87cd86b43bae8fd0272a4f764bcd163f"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a87cd86b43bae8fd0272a4f764bcd163f">pivrgs_sym</a> (T const &amp;a, V const &amp;v, double eps)</td></tr>
<tr class="memdesc:a87cd86b43bae8fd0272a4f764bcd163f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrized rank-revealing pivoted reorthogonalized Gram-Schmidt, with matrix augmented by a vector.  <a href="namespacecppdlr.html#a87cd86b43bae8fd0272a4f764bcd163f">More...</a><br /></td></tr>
<tr class="separator:a87cd86b43bae8fd0272a4f764bcd163f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240eb87e88ef0bdc5994d57fe9b7d3a1"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray Ta, nda::MemoryArray Tb, nda::Scalar Sa = nda::get_value_t&lt;Ta&gt;, nda::Scalar Sb = nda::get_value_t&lt;Tb&gt;, nda::Scalar S = typename std::common_type&lt;Sa, Sb&gt;::type&gt; </td></tr>
<tr class="memitem:a240eb87e88ef0bdc5994d57fe9b7d3a1"><td class="memTemplItemLeft" align="right" valign="top">nda::array&lt; S, Ta::rank+Tb::rank - 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a240eb87e88ef0bdc5994d57fe9b7d3a1">arraymult</a> (Ta const &amp;a, Tb const &amp;b)</td></tr>
<tr class="memdesc:a240eb87e88ef0bdc5994d57fe9b7d3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract the last dimension of an array a with the first dimension of an array b.  <a href="namespacecppdlr.html#a240eb87e88ef0bdc5994d57fe9b7d3a1">More...</a><br /></td></tr>
<tr class="separator:a240eb87e88ef0bdc5994d57fe9b7d3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93826a1ab8ed29d304e0194fefd4e19c"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a93826a1ab8ed29d304e0194fefd4e19c"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a93826a1ab8ed29d304e0194fefd4e19c">adapgl</a> (std::function&lt; nda::array&lt; S, 1 &gt;(nda::array&lt; double, 1 &gt;)&gt; f, double a, double b, double tol, nda::vector&lt; double &gt; xgl, nda::vector&lt; double &gt; wgl)</td></tr>
<tr class="memdesc:a93826a1ab8ed29d304e0194fefd4e19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick and dirty adaptive Gauss quadrature.  <a href="namespacecppdlr.html#a93826a1ab8ed29d304e0194fefd4e19c">More...</a><br /></td></tr>
<tr class="separator:a93826a1ab8ed29d304e0194fefd4e19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afa13d278b5eff503e3399f445f84ab6d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecppdlr.html#afa13d278b5eff503e3399f445f84ab6da320d20930f8ff7ba461e55e30ea405c7">NONSYM</a> = false
, <a class="el" href="namespacecppdlr.html#afa13d278b5eff503e3399f445f84ab6da2926e3338e8cc759a75b8c9fac6f7d61">SYM</a> = true
 }</td></tr>
<tr class="separator:afa13d278b5eff503e3399f445f84ab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a7e33d9a03f4986937032c25ee7435"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> { <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d">Boson</a> = 0
, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee">Fermion</a> = 1
 }</td></tr>
<tr class="separator:ad0a7e33d9a03f4986937032c25ee7435"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a85cd7bdb1fd649296322df16d329ca27"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T&gt; </td></tr>
<tr class="memitem:a85cd7bdb1fd649296322df16d329ca27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a85cd7bdb1fd649296322df16d329ca27">make_real_t</a> = decltype(make_regular(real(std::declval&lt; T &gt;())))</td></tr>
<tr class="memdesc:a85cd7bdb1fd649296322df16d329ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get real-valued type corresponding to type of given nda MemoryArray.  <a href="namespacecppdlr.html#a85cd7bdb1fd649296322df16d329ca27">More...</a><br /></td></tr>
<tr class="separator:a85cd7bdb1fd649296322df16d329ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T&gt; </td></tr>
<tr class="memitem:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#af7426dd83d2c831f6ae3fa9b8e6172ad">make_cplx_t</a> = decltype(make_regular(std::declval&lt; T &gt;() *1i))</td></tr>
<tr class="memdesc:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get complex-valued type corresponding to type of given nda MemoryArray.  <a href="namespacecppdlr.html#af7426dd83d2c831f6ae3fa9b8e6172ad">More...</a><br /></td></tr>
<tr class="separator:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23dfec829ec6ed8deec469faeea3981"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S1, nda::Scalar S2&gt; </td></tr>
<tr class="memitem:ac23dfec829ec6ed8deec469faeea3981"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ac23dfec829ec6ed8deec469faeea3981">make_common_t</a> = typename <a class="el" href="structcppdlr_1_1make__common__helper.html">make_common_helper</a>&lt; T, S1, S2 &gt;::type</td></tr>
<tr class="separator:ac23dfec829ec6ed8deec469faeea3981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad6845f613df7f7b14c43c1776464dc55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ad6845f613df7f7b14c43c1776464dc55">itops</a></td></tr>
<tr class="separator:ad6845f613df7f7b14c43c1776464dc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78129915b4883af7ef355b517eb130f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const Ht const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a78129915b4883af7ef355b517eb130f3">h</a></td></tr>
<tr class="separator:a78129915b4883af7ef355b517eb130f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cfde70e959b26df44918ee98d29bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const Ht const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ab7cfde70e959b26df44918ee98d29bab">mu</a> = 0</td></tr>
<tr class="separator:ab7cfde70e959b26df44918ee98d29bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef0a162a809071b83fd09f578db52bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const Ht const double bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#afef0a162a809071b83fd09f578db52bf">time_order</a></td></tr>
<tr class="separator:afef0a162a809071b83fd09f578db52bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac23dfec829ec6ed8deec469faeea3981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23dfec829ec6ed8deec469faeea3981">&#9670;&nbsp;</a></span>make_common_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S1, nda::Scalar S2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppdlr.html#ac23dfec829ec6ed8deec469faeea3981">cppdlr::make_common_t</a> = typedef typename <a class="el" href="structcppdlr_1_1make__common__helper.html">make_common_helper</a>&lt;T, S1, S2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7426dd83d2c831f6ae3fa9b8e6172ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7426dd83d2c831f6ae3fa9b8e6172ad">&#9670;&nbsp;</a></span>make_cplx_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppdlr.html#af7426dd83d2c831f6ae3fa9b8e6172ad">cppdlr::make_cplx_t</a> = typedef decltype(make_regular(std::declval&lt;T&gt;() * 1i))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get complex-valued type corresponding to type of given nda MemoryArray. </p>

</div>
</div>
<a id="a85cd7bdb1fd649296322df16d329ca27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cd7bdb1fd649296322df16d329ca27">&#9670;&nbsp;</a></span>make_real_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppdlr.html#a85cd7bdb1fd649296322df16d329ca27">cppdlr::make_real_t</a> = typedef decltype(make_regular(real(std::declval&lt;T&gt;())))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get real-valued type corresponding to type of given nda MemoryArray. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afa13d278b5eff503e3399f445f84ab6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa13d278b5eff503e3399f445f84ab6d">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Option for unsymmetrized or symmetrized DLR </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afa13d278b5eff503e3399f445f84ab6da320d20930f8ff7ba461e55e30ea405c7"></a>NONSYM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afa13d278b5eff503e3399f445f84ab6da2926e3338e8cc759a75b8c9fac6f7d61"></a>SYM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad0a7e33d9a03f4986937032c25ee7435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a7e33d9a03f4986937032c25ee7435">&#9670;&nbsp;</a></span>statistic_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">cppdlr::statistic_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Particle Statistic: Boson or Fermion </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d"></a>Boson&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee"></a>Fermion&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a791b659aaebe1e52cf12edb3b089b224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b659aaebe1e52cf12edb3b089b224">&#9670;&nbsp;</a></span>abs2rel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::abs2rel </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_abs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from relative to absolute time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Vector of points on [0,1] in relative time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in absolute time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Converting a point from relative to absolute time format will, in general, result in a loss of relative accuracy in the location of the point if the point is close to t = 1. For example, in three-digit arithmetic, the point t = 0.999111 could be stored in relative format as t^* = -0.889e-3, but only as t = 0.999 in absolute format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. </dd></dl>

</div>
</div>
<a id="a103a8aae4c8af512d2682d381a676561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103a8aae4c8af512d2682d381a676561">&#9670;&nbsp;</a></span>abs2rel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::abs2rel </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t_abs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from absolute to relative time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_abs</td><td>Vector of points on [0,1] in absolute time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in relative time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>cppdlr uses the relative time format to describe imaginary time points. Therefore, if you wish to specify an imaginary time point in the standard absolute time format, for example to specify a point at which to evaluate a DLR expansion, you must first convert the point to the relative time format using this function. However, in order to maintain full relative precision in all calculations, you must conform to the cppdlr standard and specify point in the relative time format from the beginning. On the other hand, in most cases only a mild loss of accuracy will result from beginning with the absolute format and then converting to the relative format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. </dd></dl>

</div>
</div>
<a id="a93826a1ab8ed29d304e0194fefd4e19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93826a1ab8ed29d304e0194fefd4e19c">&#9670;&nbsp;</a></span>adapgl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S cppdlr::adapgl </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; nda::array&lt; S, 1 &gt;(nda::array&lt; double, 1 &gt;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>xgl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>wgl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quick and dirty adaptive Gauss quadrature. </p>
<p>This function implements adaptive Gauss-Legendre quadrature with local error estimation only, using a stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function to be integrated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Lower integration limit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Upper integration limit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Absolute error tolerance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xgl</td><td>Gauss-Legendre nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wgl</td><td>Gauss-Legendre weights</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral of <code>f</code> from <code>a</code> to <code>b</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a quick and dirty adaptive integration function, which tries to achieve an error tolerance <code>tol</code> but doesn't guarantee it. A more robust implementation would use global error estimation. Nevertheless, this works quite well most of the time. </dd></dl>

</div>
</div>
<a id="a240eb87e88ef0bdc5994d57fe9b7d3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240eb87e88ef0bdc5994d57fe9b7d3a1">&#9670;&nbsp;</a></span>arraymult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray Ta, nda::MemoryArray Tb, nda::Scalar Sa = nda::get_value_t&lt;Ta&gt;, nda::Scalar Sb = nda::get_value_t&lt;Tb&gt;, nda::Scalar S = typename std::common_type&lt;Sa, Sb&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">nda::array&lt;S, Ta::rank + Tb::rank - 2&gt; cppdlr::arraymult </td>
          <td>(</td>
          <td class="paramtype">Ta const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tb const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contract the last dimension of an array a with the first dimension of an array b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An array/matrix/vector or array/matrix/vector view of rank at least 2 </td></tr>
    <tr><td class="paramname">b</td><td>An array/matrix/vector or array/matrix/vector view of rank at least 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contraction of the inner dimensions of <code>a</code> and <code>b</code> </dd></dl>

</div>
</div>
<a id="aa355c3aaf829296d7e5869eff98fedd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa355c3aaf829296d7e5869eff98fedd1">&#9670;&nbsp;</a></span>baryinterp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::baryinterp </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xeval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Barycentric Lagrange interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Interpolation nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Barycentric interpolation weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function values at interpolation nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xeval</td><td>Point at which to evaluate interpolated function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated function value at xeval </dd></dl>

</div>
</div>
<a id="ace84f47b6cc94a562dfd5207791c27b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace84f47b6cc94a562dfd5207791c27b0">&#9670;&nbsp;</a></span>build_dlr_rf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_dlr_rf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct DLR basis by obtaining DLR frequencies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>DLR cutoff parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>Accuracy of DLR basis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLR frequencies</dd></dl>
<dl class="section note"><dt>Note</dt><dd>With this signature, the DLR frequencies are unsymmetrized. </dd></dl>

</div>
</div>
<a id="a134a65b6f951a80cb99e41d52d89f0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134a65b6f951a80cb99e41d52d89f0ed">&#9670;&nbsp;</a></span>build_dlr_rf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_dlr_rf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetrize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct DLR basis by obtaining DLR frequencies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>DLR cutoff parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>Accuracy of DLR basis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle statistics: Boson or Fermion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmetrize</td><td>NONSYM or false for non-symmetrized DLR frequencies, SYM or true for symmetrized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLR frequencies</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In case Boson and SYM options are selected, we enforce that omega = 0 is chosen as a DLR frequency. For an explanation, please see the "Symmetrized DLR grids" subsection in the "Background" section of the documentation. </dd></dl>

</div>
</div>
<a id="afa672c293b0b90ab5045fbb091a1ed57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa672c293b0b90ab5045fbb091a1ed57">&#9670;&nbsp;</a></span>build_it_fine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt; cppdlr::build_it_fine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;&#160;</td>
          <td class="paramname"><em>fine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get fine composite Legendre grid in imaginary time and corresponding square root quadrature weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fine</td><td>Fine grid parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple containing fine imaginary time grid and corresponding square root quadrature weights</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Fine imaginary time grid is given in relative format </dd></dl>

</div>
</div>
<a id="a988f80420d11cd80ac3803bd3bd429c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988f80420d11cd80ac3803bd3bd429c0">&#9670;&nbsp;</a></span>build_k_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt; dcomplex &gt; cppdlr::build_k_if </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary frequency discretization of analytic continuation kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmax</td><td>Imaginary frequency cutoff </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle Statistic: Boson or Fermion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="ab471fd1439bcd11be6bc10de9703138a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab471fd1439bcd11be6bc10de9703138a">&#9670;&nbsp;</a></span>build_k_it() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="ad4b931a8f12802eee8e74307c655ca85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b931a8f12802eee8e74307c655ca85">&#9670;&nbsp;</a></span>build_k_it() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="a38c50dbbe81c1821676393f8584fb3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c50dbbe81c1821676393f8584fb3f6">&#9670;&nbsp;</a></span>build_k_it() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="a45377bb09b54d66487cf379b1a6037de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45377bb09b54d66487cf379b1a6037de">&#9670;&nbsp;</a></span>build_k_it() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel with L^2 weighting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Square root quadrature weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="ad6df2a0cc73644667ba77bf562a9e140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6df2a0cc73644667ba77bf562a9e140">&#9670;&nbsp;</a></span>build_k_it() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel with L^2 weighting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Square root quadrature weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="a83cde5c4ed014eb53f7c16392a41733e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cde5c4ed014eb53f7c16392a41733e">&#9670;&nbsp;</a></span>build_rf_fine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_rf_fine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;&#160;</td>
          <td class="paramname"><em>fine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build fine composite Chebyshev grid in real frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fine</td><td>Fine grid parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Fine real frequency grid </dd></dl>

</div>
</div>
<a id="a2d46bf12944fe36c90343df67e2d783b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d46bf12944fe36c90343df67e2d783b">&#9670;&nbsp;</a></span>eqptsrel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::eqptsrel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get grid of equispaced points on [0,1] in relative time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of equispaced points on [0,1] in relative time format </dd></dl>

</div>
</div>
<a id="afbfcb627a6ab1115bb02670e7ce61219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfcb627a6ab1115bb02670e7ce61219">&#9670;&nbsp;</a></span>gaussquad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt; cppdlr::gaussquad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gauss-Legendre nodes and weights. </p>
<p>Uses Newton iteration to obtain the Gauss-Legendre nodes and weights</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of nodes and weights </dd></dl>

</div>
</div>
<a id="a48fb848c5a66d6141ad240d2e749aec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fb848c5a66d6141ad240d2e749aec9">&#9670;&nbsp;</a></span>geterr_k_it()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, double &gt; cppdlr::geterr_k_it </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::matrix_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>kmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get error of fine composite Chebyshev discretization of analytic continuation kernel in imaginary time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fine</td><td>Fine grid parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kmat</td><td>Discretization of analytic continuation kernel on given grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error of given fine discretization of analytic continuation kernel in imaginary time and real frequency</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Error is given as an estimate of the maximum absolute value of the difference between the given discretization and the exact analytic continuation kernel</dd>
<dd>
<code>kmat</code> should be computed using the function get_kfine with composite Chebyshev grids produced by get_omfine and get_tfine </dd></dl>

</div>
</div>
<a id="af8f77e12b089b5ddb5b5b3cda18cf623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f77e12b089b5ddb5b5b3cda18cf623">&#9670;&nbsp;</a></span>k_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Imaginary frequency index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle Statistic: Boson or Fermion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(i nu_n,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel using dimensionless variables is K(i nu_n, om) = 1 / (i nu_n - om) with i nu_n = (2n+1) * i * pi (fermionic case) or i nu_n = 2n * i * pi (bosonic case). </dd></dl>

</div>
</div>
<a id="a672098c598c55c8f9da60cd194a741ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672098c598c55c8f9da60cd194a741ea">&#9670;&nbsp;</a></span>k_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary frequency for a given inverse temperature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Imaginary frequency index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle Statistic: Boson or Fermion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(i nu_n,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel at a given inverse temperature beta is K(i nu_n, om) = 1 / (i nu_n - om) with i nu_n = (2n+1) * i * pi / beta (fermionic case) or i nu_n = 2n * i * pi / beta (bosonic case). </dd></dl>

</div>
</div>
<a id="a003438d56c2ca900d2f08af9f2ab424d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003438d56c2ca900d2f08af9f2ab424d">&#9670;&nbsp;</a></span>k_if_boson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; cppdlr::k_if_boson </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbfc2f4ecdd39b95d4419a4be35909a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfc2f4ecdd39b95d4419a4be35909a4">&#9670;&nbsp;</a></span>k_if_fermion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; cppdlr::k_if_fermion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc9726e02898098dfff8448f02f5b3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9726e02898098dfff8448f02f5b3c6">&#9670;&nbsp;</a></span>k_it() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::k_it </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary time (relative time format) using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time value (relative format) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(t,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel using dimensionless variables is K(t,om) = -exp(-t * om)/(1 + exp(-om)). </dd></dl>

</div>
</div>
<a id="a3cfc4afda9cacac00e93425fe9d45a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfc4afda9cacac00e93425fe9d45a93">&#9670;&nbsp;</a></span>k_it() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::k_it </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary time (relative time format) for a given inverse temperature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time value (relative format) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(t,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel at a given inverse temperature beta is K(t,om) = -exp(-t*om)/(1+exp(-beta * om)). </dd></dl>

</div>
</div>
<a id="a7dfaf907221eb1768418258421af703f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfaf907221eb1768418258421af703f">&#9670;&nbsp;</a></span>k_it_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::k_it_abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary time (absolute time format) using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time value (absolute format) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(t,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel using dimensionless variables is K(t,om) = -exp(-t * om)/(1 + exp(-om)). </dd></dl>

</div>
</div>
<a id="adcede29d3876b4a265f09a56db33085d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcede29d3876b4a265f09a56db33085d">&#9670;&nbsp;</a></span>leg_eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, double &gt; cppdlr::leg_eval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate Legendre polynomial of degree n and its derivative. </p>
<p>Uses Legendre three-term recurrence</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Degree of polynomial Pn(x) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Point at which to evaluate polynomial</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of polynomial value Pn(x) and derivative Pn'(x) </dd></dl>

</div>
</div>
<a id="ac02cc711894b431452f59f40e6f17dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02cc711894b431452f59f40e6f17dac">&#9670;&nbsp;</a></span>pivrgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = get_value_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;typename T::regular_type, nda::vector&lt;double&gt;, nda::vector&lt;int&gt; &gt; cppdlr::pivrgs </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rank-revealing pivoted reorthogonalized Gram-Schmidt. </p>
<p>Determine the epsilon-rank of a matrix and return an orthogonal basis of its epsilon-row space.</p>
<p>This is a translation of the Fortran subroutine "qrdgrm" by V. Rokhlin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Matrix to be orthogonalized </td></tr>
    <tr><td class="paramname">eps</td><td>Rank cutoff tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (1) matrix whose rows form orthogonal basis of row space of <code>a</code> to <code>eps</code> tolerance, (2) vector with entry n given by the squared l2 norm of the orthogonal complement of nth selected row with respect to subspace spanned by first n-1 selected rows, (3) vector of pivots </dd></dl>

</div>
</div>
<a id="a65790598f458616dbc7fc84ab3cfe02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65790598f458616dbc7fc84ab3cfe02c">&#9670;&nbsp;</a></span>pivrgs_sym() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = get_value_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;typename T::regular_type, nda::vector&lt;double&gt;, nda::vector&lt;int&gt; &gt; cppdlr::pivrgs_sym </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrized rank-revealing pivoted reorthogonalized Gram-Schmidt. </p>
<p>Determine the epsilon-rank of a matrix and return an orthogonal basis of its epsilon-row space, enforcing symmetrization of pivots.</p>
<p>This is a translation of the Fortran subroutine "qrdgrm" by V. Rokhlin, with symmetrization added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Matrix to be orthogonalized </td></tr>
    <tr><td class="paramname">eps</td><td>Rank cutoff tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (1) matrix whose rows form orthogonal basis of row space of <code>a</code> to <code>eps</code> tolerance, (2) vector with entry n given by the squared l2 norm of the orthogonal complement of nth selected row with respect to subspace spanned by first n-1 selected rows, (3) vector of pivots</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The input matrix A must have an even number of rows. The symmetrization condition is that if A(i,:), the ith row of A, is selected as a pivot, then A(m-i-1,:) is also selected as a pivot. Here, m is the row dimension of A, and A is zero-indexed. </dd></dl>

</div>
</div>
<a id="a87cd86b43bae8fd0272a4f764bcd163f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cd86b43bae8fd0272a4f764bcd163f">&#9670;&nbsp;</a></span>pivrgs_sym() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, nda::Scalar S = get_value_t&lt;T&gt;, nda::MemoryVector V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;typename T::regular_type, nda::vector&lt;double&gt;, nda::vector&lt;int&gt; &gt; cppdlr::pivrgs_sym </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrized rank-revealing pivoted reorthogonalized Gram-Schmidt, with matrix augmented by a vector. </p>
<p>Determine the epsilon-rank of a matrix, augmented with a row vector, and return an orthogonal basis of the epsilon-row space of the augmented matrix, enforcing symmetrization of pivots and the selection of the provided vector.</p>
<p>This is a translation of the Fortran subroutine "qrdgrm" by V. Rokhlin, with symmetrization added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Matrix to be orthogonalized </td></tr>
    <tr><td class="paramname">v</td><td>Row vector to append to matrix </td></tr>
    <tr><td class="paramname">eps</td><td>Rank cutoff tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (1) matrix whose rows form orthogonal basis of row space of <code>a</code> appended by <code>v</code>, to <code>eps</code> tolerance, (2) vector with entry n given by the squared l2 norm of the orthogonal complement of nth selected row with respect to subspace spanned by first n-1 selected rows, (3) vector of pivots. Note that the provided vector is always selected as the first pivot before the main pivoting procedure begins; the first row of the return matrix is always the normalization of the provided vector, and the first entry of the vector of pivots is always zero, corresponding to the provided vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The (un-augmented) input matrix A must have an even number of rows. The symmetrization condition is that if A(i,:), the ith row of A, is selected as a pivot, then A(m-i-1,:) is also selected as a pivot. Here, m is the row dimension of A, and A is zero-indexed. This does not include the provided row vector, which is always selected as a pivot. </dd></dl>

</div>
</div>
<a id="a373b198ea4a2d60eb80052dc0d4ae229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373b198ea4a2d60eb80052dc0d4ae229">&#9670;&nbsp;</a></span>rel2abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::rel2abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from relative to absolute time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Vector of points on [0,1] in relative time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in absolute time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Converting a point from relative to absolute time format will, in general, result in a loss of relative accuracy in the location of the point if the point is close to t = 1. For example, in three-digit arithmetic, the point t = 0.999111 could be stored in relative format as t^* = -0.889e-3, but only as t = 0.999 in absolute format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. </dd></dl>

</div>
</div>
<a id="a3b1ccba6393dfc517757677a13ad2553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1ccba6393dfc517757677a13ad2553">&#9670;&nbsp;</a></span>rel2abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::rel2abs </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from relative to absolute time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Vector of points on [0,1] in relative time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in absolute time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Converting a point from relative to absolute time format will, in general, result in a loss of relative accuracy in the location of the point if the point is close to t = 1. For example, in three-digit arithmetic, the point t = 0.999111 could be stored in relative format as t^* = -0.889e-3, but only as t = 0.999 in absolute format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. </dd></dl>

</div>
</div>
<a id="a59a73f63b1734b37ef26f7edf1ca0034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a73f63b1734b37ef26f7edf1ca0034">&#9670;&nbsp;</a></span>requires() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ht &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cppdlr::requires </td>
          <td>(</td>
          <td class="paramtype">std::floating_point&lt; Ht &gt;||nda::MemoryMatrix&lt; Ht &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute free-particle imaginary time Green's function for a given Hamiltonian. </p>
<p>The Green's function is computed by diagonalizing the Hamiltonian, and is returned by its values at the DLR imaginary time nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td><a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hamiltonian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>Chemical potential </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY, default) or time-ordered (true or TIME_ORDERED) Dyson equation, which changes free Green's function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Green's function at DLR imaginary time nodes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Hamiltonian must either be a symmetric matrix, a Hermitian matrix, or a real scalar. </dd></dl>

</div>
</div>
<a id="acd50fc5abb306456b4b2710bea369c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd50fc5abb306456b4b2710bea369c1a">&#9670;&nbsp;</a></span>requires() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ht , nda::Scalar Sh = std::conditional_t&lt;std::floating_point&lt;Ht&gt;, Ht, get_value_t&lt;Ht&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cppdlr::requires </td>
          <td>(</td>
          <td class="paramtype">std::floating_point&lt; Ht &gt;||nda::MemoryMatrix&lt; Ht &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for <a class="el" href="classdyson__it.html" title="Class for solving Dyson equation in imaginary time.">dyson_it</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itops</td><td>DLR imaginary time object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hamiltonian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>Chemical potential (default = 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY, default) or time-ordered (true or TIME_ORDERED) Dyson equation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Hamiltonian must either be a symmetric matrix, a Hermitian matrix, or a real scalar.</dd></dl>
<p>Constructor for <a class="el" href="classdyson__it.html" title="Class for solving Dyson equation in imaginary time.">dyson_it</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itops</td><td>DLR imaginary time object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hamiltonian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY) or time-ordered (true or TIME_ORDERED) Dyson equation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Hamiltonian must either be a symmetric matrix, a Hermitian matrix, or a real scalar.</dd></dl>
<p>Solve Dyson equation for given self-energy</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tsig</td><td>Type of self-energy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Self-energy at DLR imaginary time nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Green's function at DLR imaginary time nodes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Free Green's function (right hand side of Dyson equation) specified at construction of <a class="el" href="classdyson__it.html" title="Class for solving Dyson equation in imaginary time.">dyson_it</a> object</dd></dl>
<p>&lt; Inverse temperature</p>
<p>&lt; shared pointer to <a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a> object</p>
<p>&lt; Number of orbital indices</p>
<p>&lt; Flag for ordinary (false) or time-ordered (true) Dyson equation</p>
<p>&lt; Right hand side of Dyson equation (in format compatible w/ LAPACK); vector if Hamiltonian is scalar, rank-3 array otherwise</p>
<p>&lt; Matrix of convolution by free Green's function</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a78129915b4883af7ef355b517eb130f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78129915b4883af7ef355b517eb130f3">&#9670;&nbsp;</a></span>h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const Ht const&amp; cppdlr::h</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6845f613df7f7b14c43c1776464dc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6845f613df7f7b14c43c1776464dc55">&#9670;&nbsp;</a></span>itops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const&amp; cppdlr::itops</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7cfde70e959b26df44918ee98d29bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cfde70e959b26df44918ee98d29bab">&#9670;&nbsp;</a></span>mu</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const Ht const double cppdlr::mu = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afef0a162a809071b83fd09f578db52bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef0a162a809071b83fd09f578db52bf">&#9670;&nbsp;</a></span>time_order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const Ht const double bool cppdlr::time_order</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
