<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppdlr: cppdlr::imtime_ops Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cppdlr
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Imaginary time calculations using the discrete Lehmann representation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecppdlr.html">cppdlr</a></li><li class="navelem"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcppdlr_1_1imtime__ops-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cppdlr::imtime_ops Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations.  
 <a href="classcppdlr_1_1imtime__ops.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dlr__imtime_8hpp_source.html">dlr_imtime.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7">imtime_ops</a> (double <a class="el" href="classcppdlr_1_1imtime__ops.html#a401521dedc309ca12c1ec345da983c80">lambda</a>, nda::vector_const_view&lt; double &gt; dlr_rf)</td></tr>
<tr class="memdesc:a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a>.  <a href="classcppdlr_1_1imtime__ops.html#a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7">More...</a><br /></td></tr>
<tr class="separator:a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a9b5fb6aeefad7d8ae6865329e69de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a43a9b5fb6aeefad7d8ae6865329e69de">imtime_ops</a> (double <a class="el" href="classcppdlr_1_1imtime__ops.html#a401521dedc309ca12c1ec345da983c80">lambda</a>, nda::vector_const_view&lt; double &gt; dlr_rf, nda::vector_const_view&lt; double &gt; dlr_it, nda::matrix_const_view&lt; double &gt; cf2it, nda::matrix_const_view&lt; double &gt; it2cf_lu, nda::vector_const_view&lt; int &gt; it2cf_piv)</td></tr>
<tr class="separator:a43a9b5fb6aeefad7d8ae6865329e69de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da78cf54d39d48d2be19ad1f146b03c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a8da78cf54d39d48d2be19ad1f146b03c">imtime_ops</a> ()=default</td></tr>
<tr class="separator:a8da78cf54d39d48d2be19ad1f146b03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b83b15a4fa3eefe8f10d65a53b5885d"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a8b83b15a4fa3eefe8f10d65a53b5885d"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a8b83b15a4fa3eefe8f10d65a53b5885d">vals2coefs</a> (T const &amp;g) const</td></tr>
<tr class="memdesc:a8b83b15a4fa3eefe8f10d65a53b5885d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform values of Green's function G on DLR imaginary time grid to DLR coefficients.  <a href="classcppdlr_1_1imtime__ops.html#a8b83b15a4fa3eefe8f10d65a53b5885d">More...</a><br /></td></tr>
<tr class="separator:a8b83b15a4fa3eefe8f10d65a53b5885d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6d71c061aec134df9edf1255e19dfb"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6f6d71c061aec134df9edf1255e19dfb"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a6f6d71c061aec134df9edf1255e19dfb">coefs2vals</a> (T const &amp;gc) const</td></tr>
<tr class="memdesc:a6f6d71c061aec134df9edf1255e19dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform DLR coefficients of Green's function G to values on DLR imaginary time grid.  <a href="classcppdlr_1_1imtime__ops.html#a6f6d71c061aec134df9edf1255e19dfb">More...</a><br /></td></tr>
<tr class="separator:a6f6d71c061aec134df9edf1255e19dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12761a877407fc347dc695da4b2d7f3d"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a12761a877407fc347dc695da4b2d7f3d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a12761a877407fc347dc695da4b2d7f3d">coefs2eval</a> (T const &amp;gc, double t) const</td></tr>
<tr class="memdesc:a12761a877407fc347dc695da4b2d7f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate DLR expansion of G, given by its DLR coefficients, at imaginary time point.  <a href="classcppdlr_1_1imtime__ops.html#a12761a877407fc347dc695da4b2d7f3d">More...</a><br /></td></tr>
<tr class="separator:a12761a877407fc347dc695da4b2d7f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318b0b4409d0488814bb8db12c8b0611"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a318b0b4409d0488814bb8db12c8b0611">build_evalvec</a> (double t) const</td></tr>
<tr class="memdesc:a318b0b4409d0488814bb8db12c8b0611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build vector of evaluation of DLR expansion at an imaginary time point.  <a href="classcppdlr_1_1imtime__ops.html#a318b0b4409d0488814bb8db12c8b0611">More...</a><br /></td></tr>
<tr class="separator:a318b0b4409d0488814bb8db12c8b0611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a81a99b2858defa9513a395bd35e2bf"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6a81a99b2858defa9513a395bd35e2bf"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a6a81a99b2858defa9513a395bd35e2bf">fitvals2coefs</a> (nda::vector_const_view&lt; double &gt; t, T const &amp;g) const</td></tr>
<tr class="memdesc:a6a81a99b2858defa9513a395bd35e2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain DLR coefficients of a Green's function G from scattered imaginary time grid by least squares fitting.  <a href="classcppdlr_1_1imtime__ops.html#a6a81a99b2858defa9513a395bd35e2bf">More...</a><br /></td></tr>
<tr class="separator:a6a81a99b2858defa9513a395bd35e2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee9bfed6fc9facf2d25cea9868a3af6"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T&gt; </td></tr>
<tr class="memitem:a0ee9bfed6fc9facf2d25cea9868a3af6"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a0ee9bfed6fc9facf2d25cea9868a3af6">reflect</a> (T const &amp;g) const</td></tr>
<tr class="memdesc:a0ee9bfed6fc9facf2d25cea9868a3af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute reflection of imaginary time Green's function.  <a href="classcppdlr_1_1imtime__ops.html#a0ee9bfed6fc9facf2d25cea9868a3af6">More...</a><br /></td></tr>
<tr class="separator:a0ee9bfed6fc9facf2d25cea9868a3af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f018cf316547b2879d9a2dd76a4b80c"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a4f018cf316547b2879d9a2dd76a4b80c"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a4f018cf316547b2879d9a2dd76a4b80c">convolve</a> (double beta, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic, T const &amp;fc, T const &amp;gc, bool <a class="el" href="namespacecppdlr.html#afef0a162a809071b83fd09f578db52bf">time_order</a>=false) const</td></tr>
<tr class="memdesc:a4f018cf316547b2879d9a2dd76a4b80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convolution of two imaginary time Green's functions.  <a href="classcppdlr_1_1imtime__ops.html#a4f018cf316547b2879d9a2dd76a4b80c">More...</a><br /></td></tr>
<tr class="separator:a4f018cf316547b2879d9a2dd76a4b80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b3e21ae66c97691a4580335795f77f"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryMatrix Tf, nda::MemoryArray Tg, nda::Scalar Sf = nda::get_value_t&lt;Tf&gt;, nda::Scalar Sg = nda::get_value_t&lt;Tg&gt;, nda::Scalar S = typename std::common_type&lt;Sf, Sg&gt;::type&gt; </td></tr>
<tr class="memitem:a87b3e21ae66c97691a4580335795f77f"><td class="memTemplItemLeft" align="right" valign="top">Tg::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a87b3e21ae66c97691a4580335795f77f">convolve</a> (Tf const &amp;fconv, Tg const &amp;g) const</td></tr>
<tr class="memdesc:a87b3e21ae66c97691a4580335795f77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convolution of two imaginary time Green's functions, given matrix of convolution by one of them.  <a href="classcppdlr_1_1imtime__ops.html#a87b3e21ae66c97691a4580335795f77f">More...</a><br /></td></tr>
<tr class="separator:a87b3e21ae66c97691a4580335795f77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0899c199459a76210d535eab89fd3a"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a4b0899c199459a76210d535eab89fd3a"><td class="memTemplItemLeft" align="right" valign="top">nda::matrix&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a4b0899c199459a76210d535eab89fd3a">convmat</a> (double beta, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic, T const &amp;fc, bool <a class="el" href="namespacecppdlr.html#afef0a162a809071b83fd09f578db52bf">time_order</a>=false) const</td></tr>
<tr class="memdesc:a4b0899c199459a76210d535eab89fd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix of convolution by an imaginary time Green's function.  <a href="classcppdlr_1_1imtime__ops.html#a4b0899c199459a76210d535eab89fd3a">More...</a><br /></td></tr>
<tr class="separator:a4b0899c199459a76210d535eab89fd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89451028e273c8753d87621081a16cee"><td class="memItemLeft" align="right" valign="top">nda::vector_const_view&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a89451028e273c8753d87621081a16cee">get_itnodes</a> () const</td></tr>
<tr class="memdesc:a89451028e273c8753d87621081a16cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DLR imaginary time nodes.  <a href="classcppdlr_1_1imtime__ops.html#a89451028e273c8753d87621081a16cee">More...</a><br /></td></tr>
<tr class="separator:a89451028e273c8753d87621081a16cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1395480d77a2f400b62171e553b0f4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#aec1395480d77a2f400b62171e553b0f4">get_itnodes</a> (int i) const</td></tr>
<tr class="separator:aec1395480d77a2f400b62171e553b0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369d8d83b9ed6c31d8c34784d162f389"><td class="memItemLeft" align="right" valign="top">nda::vector_const_view&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a369d8d83b9ed6c31d8c34784d162f389">get_rfnodes</a> () const</td></tr>
<tr class="memdesc:a369d8d83b9ed6c31d8c34784d162f389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DLR real frequency nodes.  <a href="classcppdlr_1_1imtime__ops.html#a369d8d83b9ed6c31d8c34784d162f389">More...</a><br /></td></tr>
<tr class="separator:a369d8d83b9ed6c31d8c34784d162f389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58745b133d7a289d897c920ee89f671"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#ac58745b133d7a289d897c920ee89f671">get_rfnodes</a> (int i) const</td></tr>
<tr class="separator:ac58745b133d7a289d897c920ee89f671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278304f50e778063a60df49be4d89909"><td class="memItemLeft" align="right" valign="top">nda::matrix_const_view&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a278304f50e778063a60df49be4d89909">get_cf2it</a> () const</td></tr>
<tr class="memdesc:a278304f50e778063a60df49be4d89909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get transformation matrix from DLR coefficients to values at DLR imaginary time nodes.  <a href="classcppdlr_1_1imtime__ops.html#a278304f50e778063a60df49be4d89909">More...</a><br /></td></tr>
<tr class="separator:a278304f50e778063a60df49be4d89909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b17e780b762dde6a25d8f8e844dab3"><td class="memItemLeft" align="right" valign="top">nda::matrix_const_view&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#af2b17e780b762dde6a25d8f8e844dab3">get_it2cf_lu</a> () const</td></tr>
<tr class="memdesc:af2b17e780b762dde6a25d8f8e844dab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LU factors of transformation matrix from DLR imaginary time values to coefficients.  <a href="classcppdlr_1_1imtime__ops.html#af2b17e780b762dde6a25d8f8e844dab3">More...</a><br /></td></tr>
<tr class="separator:af2b17e780b762dde6a25d8f8e844dab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0575ff4a9de9b9c6c186b9f002cc53"><td class="memItemLeft" align="right" valign="top">nda::vector_const_view&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#acc0575ff4a9de9b9c6c186b9f002cc53">get_it2cf_piv</a> () const</td></tr>
<tr class="memdesc:acc0575ff4a9de9b9c6c186b9f002cc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LU pivots of transformation matrix from DLR imaginary time values to coefficients.  <a href="classcppdlr_1_1imtime__ops.html#acc0575ff4a9de9b9c6c186b9f002cc53">More...</a><br /></td></tr>
<tr class="separator:acc0575ff4a9de9b9c6c186b9f002cc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f437cb31c98929ab8a1e6dadb174aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a88f437cb31c98929ab8a1e6dadb174aa">rank</a> () const</td></tr>
<tr class="memdesc:a88f437cb31c98929ab8a1e6dadb174aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DLR rank.  <a href="classcppdlr_1_1imtime__ops.html#a88f437cb31c98929ab8a1e6dadb174aa">More...</a><br /></td></tr>
<tr class="separator:a88f437cb31c98929ab8a1e6dadb174aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401521dedc309ca12c1ec345da983c80"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a401521dedc309ca12c1ec345da983c80">lambda</a> () const</td></tr>
<tr class="separator:a401521dedc309ca12c1ec345da983c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6257e0b3f43733c5ac06c8af11a47bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a6257e0b3f43733c5ac06c8af11a47bb3">convolve_init</a> () const</td></tr>
<tr class="memdesc:a6257e0b3f43733c5ac06c8af11a47bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for convolution methods.  <a href="classcppdlr_1_1imtime__ops.html#a6257e0b3f43733c5ac06c8af11a47bb3">More...</a><br /></td></tr>
<tr class="separator:a6257e0b3f43733c5ac06c8af11a47bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6116f42e1f17050404974d0d6d3d226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#ae6116f42e1f17050404974d0d6d3d226">tconvolve_init</a> () const</td></tr>
<tr class="memdesc:ae6116f42e1f17050404974d0d6d3d226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for time-ordered convolution methods.  <a href="classcppdlr_1_1imtime__ops.html#ae6116f42e1f17050404974d0d6d3d226">More...</a><br /></td></tr>
<tr class="separator:ae6116f42e1f17050404974d0d6d3d226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a47942235e7330cc6d392dc881d256f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a3a47942235e7330cc6d392dc881d256f">reflect_init</a> () const</td></tr>
<tr class="memdesc:a3a47942235e7330cc6d392dc881d256f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for reflection method.  <a href="classcppdlr_1_1imtime__ops.html#a3a47942235e7330cc6d392dc881d256f">More...</a><br /></td></tr>
<tr class="separator:a3a47942235e7330cc6d392dc881d256f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a649d9f6c3d257661818c3f473f49f57a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a649d9f6c3d257661818c3f473f49f57a">hdf5_format</a> ()</td></tr>
<tr class="separator:a649d9f6c3d257661818c3f473f49f57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0eec6aaaea35d7bba7e92951a0de76db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a0eec6aaaea35d7bba7e92951a0de76db">h5_write</a> (h5::group fg, std::string const &amp;subgroup_name, <a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;m)</td></tr>
<tr class="separator:a0eec6aaaea35d7bba7e92951a0de76db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e5f8519e54734a74b94226d10e082d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a02e5f8519e54734a74b94226d10e082d">h5_read</a> (h5::group fg, std::string const &amp;subgroup_name, <a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> &amp;m)</td></tr>
<tr class="separator:a02e5f8519e54734a74b94226d10e082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations. </p>
<dl class="section note"><dt>Note</dt><dd>First dimension of all Green's function and coefficient arrays must be DLR rank r. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7">&#9670;&nbsp;</a></span>imtime_ops() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cppdlr::imtime_ops::imtime_ops </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>dlr_rf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>DLR cutoff parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dlr_rf</td><td>DLR frequencies </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43a9b5fb6aeefad7d8ae6865329e69de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a9b5fb6aeefad7d8ae6865329e69de">&#9670;&nbsp;</a></span>imtime_ops() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cppdlr::imtime_ops::imtime_ops </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>dlr_rf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>dlr_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::matrix_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>cf2it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::matrix_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>it2cf_lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; int &gt;&#160;</td>
          <td class="paramname"><em>it2cf_piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8da78cf54d39d48d2be19ad1f146b03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da78cf54d39d48d2be19ad1f146b03c">&#9670;&nbsp;</a></span>imtime_ops() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cppdlr::imtime_ops::imtime_ops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a318b0b4409d0488814bb8db12c8b0611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318b0b4409d0488814bb8db12c8b0611">&#9670;&nbsp;</a></span>build_evalvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::imtime_ops::build_evalvec </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build vector of evaluation of DLR expansion at an imaginary time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Evaluation point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of evaluation at <code>t</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The given evaluation point must be scaled to the interval [0, 1] (rather than [0, beta]) and then given in the relative time format. Please see the "Imaginary time point format" section in the Background page of the documentation for more information. </dd></dl>

</div>
</div>
<a id="a12761a877407fc347dc695da4b2d7f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12761a877407fc347dc695da4b2d7f3d">&#9670;&nbsp;</a></span>coefs2eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto cppdlr::imtime_ops::coefs2eval </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate DLR expansion of G, given by its DLR coefficients, at imaginary time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gc</td><td>DLR coefficients of G </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Evaluation point, in relative format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of G at <code>t</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The given evaluation point must be scaled to the interval [0, 1] (rather than [0, beta]) and then given in the relative time format. Please see the "Imaginary time point format" section in the Background page of the documentation for more information. </dd></dl>

</div>
</div>
<a id="a6f6d71c061aec134df9edf1255e19dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6d71c061aec134df9edf1255e19dfb">&#9670;&nbsp;</a></span>coefs2vals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::coefs2vals </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>gc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform DLR coefficients of Green's function G to values on DLR imaginary time grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gc</td><td>DLR coefficients of G</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values of G on DLR imaginary time grid </dd></dl>

</div>
</div>
<a id="a4b0899c199459a76210d535eab89fd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0899c199459a76210d535eab89fd3a">&#9670;&nbsp;</a></span>convmat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt;S&gt; cppdlr::imtime_ops::convmat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>time_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute matrix of convolution by an imaginary time Green's function. </p>
<p>The convolution of f and g is defined as h(t) = (f * g)(t) = int_0^beta f(t-t') g(t') dt', where fermionic/bosonic antiperiodicity/periodicity are used to define the Green's functions on (-beta, 0). This method takes the DLR coefficients of f as input and returns the matrix of convolution by f. This matrix can be applied to the values of g on the DLR imaginary time grid, to produce the values of h on the DLR imaginary time grid.</p>
<p>By specifying the <code>time_order</code> flag, this method can be used to compute the time-ordered convolution of f and g, defined as h(t) = (f * g)(t) = int_0^tau f(t-t') g(t') dt'.</p>
<p>The convolution matrix is constructed using the method described in Appendix A of</p>
<p>J. Kaye, H. U. R. Strand, D. Golez, "Decomposing imaginary time Feynman diagrams using separable basis functions: Anderson impurity model strong coupling expansion," arXiv:2307.08566 (2023).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Fermionic ("Fermion" or 0) or bosonic ("Boson" or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc</td><td>DLR coefficients of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY, default) or time-ordered (true or TIME_ORDERED) convolution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of convolution by f</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whereas the method <a class="el" href="classcppdlr_1_1imtime__ops.html#a4f018cf316547b2879d9a2dd76a4b80c" title="Compute convolution of two imaginary time Green&#39;s functions.">imtime_ops::convolve</a> takes the DLR coefficients of f and g as input and computes their convolution h directly, this method returns a matrix which should be applied to the DLR imaginary time grid values of g, rather than its DLR coefficients, in to order to obtain the convolution h. The purpose of this is to make the input and output representations of the convolution matrix equal, which is often convenient in practice.</dd>
<dd>
In the case of matrix-valued Green's functions, we think of the matrix of convolution by f as an r*norb x r*norb matrix, or a block r x r matrix of norb x norb blocks. Here r is the DLR rank and norb is the number of orbital indices. This matrix would then be applied to a Green's function g, represented as an r*norb x norb matrix, or a block r x 1 matrix of norb x norb blocks. </dd></dl>

</div>
</div>
<a id="a4f018cf316547b2879d9a2dd76a4b80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f018cf316547b2879d9a2dd76a4b80c">&#9670;&nbsp;</a></span>convolve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::convolve </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>time_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute convolution of two imaginary time Green's functions. </p>
<p>The convolution of f and g is defined as h(t) = (f * g)(t) = int_0^beta f(t-t') g(t') dt', where fermionic/bosonic antiperiodicity/periodicity are used to define the Green's functions on (-beta, 0). This method takes the DLR coefficients of f and g as input and returns the values of h on the DLR imaginary time grid.</p>
<p>By specifying the <code>time_order</code> flag, this method can be used to compute the time-ordered convolution of f and g, defined as h(t) = (f * g)(t) = int_0^tau f(t-t') g(t') dt'.</p>
<p>The convolution is computed on-the-fly in O(r^2) operations using the method described in Appendix A of</p>
<p>J. Kaye, H. U. R. Strand, D. Golez, "Decomposing imaginary time Feynman diagrams using separable basis functions: Anderson impurity model strong coupling expansion," arXiv:2307.08566 (2023).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Fermionic ("Fermion" or 0) or bosonic ("Boson" or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc</td><td>DLR coefficients of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gc</td><td>DLR coefficients of g </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY, default) or time-ordered (true or TIME_ORDERED) convolution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values of h = f * g on DLR imaginary time grid </dd></dl>

</div>
</div>
<a id="a87b3e21ae66c97691a4580335795f77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b3e21ae66c97691a4580335795f77f">&#9670;&nbsp;</a></span>convolve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryMatrix Tf, nda::MemoryArray Tg, nda::Scalar Sf = nda::get_value_t&lt;Tf&gt;, nda::Scalar Sg = nda::get_value_t&lt;Tg&gt;, nda::Scalar S = typename std::common_type&lt;Sf, Sg&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tg::regular_type cppdlr::imtime_ops::convolve </td>
          <td>(</td>
          <td class="paramtype">Tf const &amp;&#160;</td>
          <td class="paramname"><em>fconv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tg const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute convolution of two imaginary time Green's functions, given matrix of convolution by one of them. </p>
<p>The convolution of f and g is defined as h(t) = (f * g)(t) = int_0^beta f(t-t') g(t') dt', where fermionic/bosonic antiperiodicity/periodicity are used to define the Green's functions on (-beta, 0). This method takes the matrix of convolution by f (computed by the convmat method) and the values of g on the DLR imaginary time grid, and returns the values of h on the DLR imaginary time grid</p>
<p>By passing in the matrix of time-ordered convolution by f (computed by the convmat method with the <code>time_order</code> flag set to true, or TIME_ORDERED), this method can be used to compute the time-ordered convolution of f and g, defined as h(t) = (f * g)(t) = int_0^tau f(t-t') g(t') dt'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fconv</td><td>Matrix of convolution by f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Values of g on the DLR imaginary time grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values of h = f * g on DLR imaginary time grid </dd></dl>

</div>
</div>
<a id="a6257e0b3f43733c5ac06c8af11a47bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6257e0b3f43733c5ac06c8af11a47bb3">&#9670;&nbsp;</a></span>convolve_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::convolve_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization for convolution methods. </p>
<p>Initialize matrices required for the convolution methods. This method is called automatically the first time one of the relevant convolution methods is called, but it may also be called manually to avoid the additional overhead in the first convolution call. </p>

</div>
</div>
<a id="a6a81a99b2858defa9513a395bd35e2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a81a99b2858defa9513a395bd35e2bf">&#9670;&nbsp;</a></span>fitvals2coefs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::fitvals2coefs </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain DLR coefficients of a Green's function G from scattered imaginary time grid by least squares fitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid points at which G is sampled, in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Values of G on grid t</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLR coefficients of G </dd></dl>

</div>
</div>
<a id="a278304f50e778063a60df49be4d89909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278304f50e778063a60df49be4d89909">&#9670;&nbsp;</a></span>get_cf2it()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix_const_view&lt;double&gt; cppdlr::imtime_ops::get_cf2it </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get transformation matrix from DLR coefficients to values at DLR imaginary time nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Transformation matrix </dd></dl>

</div>
</div>
<a id="af2b17e780b762dde6a25d8f8e844dab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b17e780b762dde6a25d8f8e844dab3">&#9670;&nbsp;</a></span>get_it2cf_lu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix_const_view&lt;double&gt; cppdlr::imtime_ops::get_it2cf_lu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get LU factors of transformation matrix from DLR imaginary time values to coefficients. </p>
<dl class="section return"><dt>Returns</dt><dd>LU factors </dd></dl>

</div>
</div>
<a id="acc0575ff4a9de9b9c6c186b9f002cc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0575ff4a9de9b9c6c186b9f002cc53">&#9670;&nbsp;</a></span>get_it2cf_piv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector_const_view&lt;int&gt; cppdlr::imtime_ops::get_it2cf_piv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get LU pivots of transformation matrix from DLR imaginary time values to coefficients. </p>
<dl class="section return"><dt>Returns</dt><dd>LU pivots </dd></dl>

</div>
</div>
<a id="a89451028e273c8753d87621081a16cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89451028e273c8753d87621081a16cee">&#9670;&nbsp;</a></span>get_itnodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector_const_view&lt;double&gt; cppdlr::imtime_ops::get_itnodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get DLR imaginary time nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>DLR imaginary time nodes </dd></dl>

</div>
</div>
<a id="aec1395480d77a2f400b62171e553b0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1395480d77a2f400b62171e553b0f4">&#9670;&nbsp;</a></span>get_itnodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::imtime_ops::get_itnodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a369d8d83b9ed6c31d8c34784d162f389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369d8d83b9ed6c31d8c34784d162f389">&#9670;&nbsp;</a></span>get_rfnodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector_const_view&lt;double&gt; cppdlr::imtime_ops::get_rfnodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get DLR real frequency nodes. </p>
<p>Access DLR imaginary real frequency nodes</p>
<dl class="section return"><dt>Returns</dt><dd>DLR real frequency nodes </dd></dl>

</div>
</div>
<a id="ac58745b133d7a289d897c920ee89f671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58745b133d7a289d897c920ee89f671">&#9670;&nbsp;</a></span>get_rfnodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::imtime_ops::get_rfnodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a649d9f6c3d257661818c3f473f49f57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649d9f6c3d257661818c3f473f49f57a">&#9670;&nbsp;</a></span>hdf5_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string cppdlr::imtime_ops::hdf5_format </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a401521dedc309ca12c1ec345da983c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401521dedc309ca12c1ec345da983c80">&#9670;&nbsp;</a></span>lambda()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::imtime_ops::lambda </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88f437cb31c98929ab8a1e6dadb174aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f437cb31c98929ab8a1e6dadb174aa">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cppdlr::imtime_ops::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get DLR rank. </p>
<dl class="section return"><dt>Returns</dt><dd>DLR rank </dd></dl>

</div>
</div>
<a id="a0ee9bfed6fc9facf2d25cea9868a3af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee9bfed6fc9facf2d25cea9868a3af6">&#9670;&nbsp;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::reflect </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute reflection of imaginary time Green's function. </p>
<p>The reflection of g(t) is g(beta - t). This method takes the values of a Green's function g at the DLR imaginary time nodes to the values of its reflection at the DLR imaginary time nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Values of g at DLR imaginary time nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values of g(beta - t) at DLR imaginary time nodes </dd></dl>

</div>
</div>
<a id="a3a47942235e7330cc6d392dc881d256f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a47942235e7330cc6d392dc881d256f">&#9670;&nbsp;</a></span>reflect_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::reflect_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization for reflection method. </p>
<p>Initialize matrix of the reflection G(tau) -&gt; G(beta - tau) acting on the values of the Green's function at the DLR imaginary time nodes. This matrix is required for the reflect method. It is called automatically the first time the reflect method is called, but it may also be called manually to avoid the additional overhead of the first call to reflect. </p>

</div>
</div>
<a id="ae6116f42e1f17050404974d0d6d3d226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6116f42e1f17050404974d0d6d3d226">&#9670;&nbsp;</a></span>tconvolve_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::tconvolve_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization for time-ordered convolution methods. </p>
<p>Initialize matrices required for the time-ordered convolution methods. This method is called automatically the first time one of the relevant time-ordered convolution methods is called, but it may also be called manually to avoid the additional overhead in the first time-ordered convolution call. </p>

</div>
</div>
<a id="a8b83b15a4fa3eefe8f10d65a53b5885d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b83b15a4fa3eefe8f10d65a53b5885d">&#9670;&nbsp;</a></span>vals2coefs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::vals2coefs </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform values of Green's function G on DLR imaginary time grid to DLR coefficients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Values of G on DLR imaginary time grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLR coefficients of G </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a02e5f8519e54734a74b94226d10e082d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e5f8519e54734a74b94226d10e082d">&#9670;&nbsp;</a></span>h5_read</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void h5_read </td>
          <td>(</td>
          <td class="paramtype">h5::group&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>subgroup_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0eec6aaaea35d7bba7e92951a0de76db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eec6aaaea35d7bba7e92951a0de76db">&#9670;&nbsp;</a></span>h5_write</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void h5_write </td>
          <td>(</td>
          <td class="paramtype">h5::group&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>subgroup_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a83e9085aca345c3bf889ae006f0fdb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e9085aca345c3bf889ae006f0fdb3d">&#9670;&nbsp;</a></span>lu</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt;double&gt; cppdlr::imtime_ops::lu</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU factors (LAPACK format) of imaginary time vals -&gt; coefs matrix. </p>

</div>
</div>
<a id="a7cd0e6b5498400d3afade53a6ebab389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd0e6b5498400d3afade53a6ebab389">&#9670;&nbsp;</a></span>piv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt;int&gt; cppdlr::imtime_ops::piv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU pivots (LAPACK format) of imaginary time vals -&gt; coefs matrix. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/cppdlr/cppdlr/c++/cppdlr/<a class="el" href="dlr__imtime_8hpp_source.html">dlr_imtime.hpp</a></li>
<li>/home/runner/work/cppdlr/cppdlr/c++/cppdlr/<a class="el" href="dlr__imtime_8cpp.html">dlr_imtime.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
