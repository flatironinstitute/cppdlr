<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppdlr: cppdlr::imtime_ops Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">cppdlr<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Imaginary time calculations using the discrete Lehmann representation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecppdlr.html">cppdlr</a></li><li class="navelem"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcppdlr_1_1imtime__ops-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">cppdlr::imtime_ops Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations.  
 <a href="classcppdlr_1_1imtime__ops.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dlr__imtime_8hpp_source.html">dlr_imtime.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a31b2703038bafa04b59e3731ab0bf234" id="r_a31b2703038bafa04b59e3731ab0bf234"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a31b2703038bafa04b59e3731ab0bf234">imtime_ops</a> (double <a class="el" href="classcppdlr_1_1imtime__ops.html#a401521dedc309ca12c1ec345da983c80">lambda</a>, nda::vector_const_view&lt; double &gt; dlr_rf, bool symmetrize)</td></tr>
<tr class="memdesc:a31b2703038bafa04b59e3731ab0bf234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a>.  <br /></td></tr>
<tr class="separator:a31b2703038bafa04b59e3731ab0bf234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7" id="r_a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7">imtime_ops</a> (double <a class="el" href="classcppdlr_1_1imtime__ops.html#a401521dedc309ca12c1ec345da983c80">lambda</a>, nda::vector_const_view&lt; double &gt; dlr_rf)</td></tr>
<tr class="memdesc:a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a>.  <br /></td></tr>
<tr class="separator:a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a9b5fb6aeefad7d8ae6865329e69de" id="r_a43a9b5fb6aeefad7d8ae6865329e69de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a43a9b5fb6aeefad7d8ae6865329e69de">imtime_ops</a> (double <a class="el" href="classcppdlr_1_1imtime__ops.html#a401521dedc309ca12c1ec345da983c80">lambda</a>, nda::vector_const_view&lt; double &gt; dlr_rf, nda::vector_const_view&lt; double &gt; dlr_it, nda::matrix_const_view&lt; double &gt; cf2it, nda::matrix_const_view&lt; double &gt; it2cf_lu, nda::vector_const_view&lt; int &gt; it2cf_piv)</td></tr>
<tr class="separator:a43a9b5fb6aeefad7d8ae6865329e69de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da78cf54d39d48d2be19ad1f146b03c" id="r_a8da78cf54d39d48d2be19ad1f146b03c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a8da78cf54d39d48d2be19ad1f146b03c">imtime_ops</a> ()=default</td></tr>
<tr class="separator:a8da78cf54d39d48d2be19ad1f146b03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bafac0dcc76bd713c732a3792c6e0c" id="r_af5bafac0dcc76bd713c732a3792c6e0c"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:af5bafac0dcc76bd713c732a3792c6e0c"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#af5bafac0dcc76bd713c732a3792c6e0c">vals2coefs</a> (T const &amp;g, bool transpose=false) const</td></tr>
<tr class="memdesc:af5bafac0dcc76bd713c732a3792c6e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform values of Green's function G on DLR imaginary time grid to DLR coefficients.  <br /></td></tr>
<tr class="separator:af5bafac0dcc76bd713c732a3792c6e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6d71c061aec134df9edf1255e19dfb" id="r_a6f6d71c061aec134df9edf1255e19dfb"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6f6d71c061aec134df9edf1255e19dfb"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a6f6d71c061aec134df9edf1255e19dfb">coefs2vals</a> (T const &amp;gc) const</td></tr>
<tr class="memdesc:a6f6d71c061aec134df9edf1255e19dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform DLR coefficients of Green's function G to values on DLR imaginary time grid.  <br /></td></tr>
<tr class="separator:a6f6d71c061aec134df9edf1255e19dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12761a877407fc347dc695da4b2d7f3d" id="r_a12761a877407fc347dc695da4b2d7f3d"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a12761a877407fc347dc695da4b2d7f3d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a12761a877407fc347dc695da4b2d7f3d">coefs2eval</a> (T const &amp;gc, double t) const</td></tr>
<tr class="memdesc:a12761a877407fc347dc695da4b2d7f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate DLR expansion of G, given by its DLR coefficients, at imaginary time point.  <br /></td></tr>
<tr class="separator:a12761a877407fc347dc695da4b2d7f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318b0b4409d0488814bb8db12c8b0611" id="r_a318b0b4409d0488814bb8db12c8b0611"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a318b0b4409d0488814bb8db12c8b0611">build_evalvec</a> (double t) const</td></tr>
<tr class="memdesc:a318b0b4409d0488814bb8db12c8b0611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build vector of evaluation of DLR expansion at an imaginary time point.  <br /></td></tr>
<tr class="separator:a318b0b4409d0488814bb8db12c8b0611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a81a99b2858defa9513a395bd35e2bf" id="r_a6a81a99b2858defa9513a395bd35e2bf"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6a81a99b2858defa9513a395bd35e2bf"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a6a81a99b2858defa9513a395bd35e2bf">fitvals2coefs</a> (nda::vector_const_view&lt; double &gt; t, T const &amp;g) const</td></tr>
<tr class="memdesc:a6a81a99b2858defa9513a395bd35e2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain DLR coefficients of a Green's function G from scattered imaginary time grid by least squares fitting.  <br /></td></tr>
<tr class="separator:a6a81a99b2858defa9513a395bd35e2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee9bfed6fc9facf2d25cea9868a3af6" id="r_a0ee9bfed6fc9facf2d25cea9868a3af6"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T&gt; </td></tr>
<tr class="memitem:a0ee9bfed6fc9facf2d25cea9868a3af6"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a0ee9bfed6fc9facf2d25cea9868a3af6">reflect</a> (T const &amp;g) const</td></tr>
<tr class="memdesc:a0ee9bfed6fc9facf2d25cea9868a3af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute reflection of imaginary time Green's function.  <br /></td></tr>
<tr class="separator:a0ee9bfed6fc9facf2d25cea9868a3af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f018cf316547b2879d9a2dd76a4b80c" id="r_a4f018cf316547b2879d9a2dd76a4b80c"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a4f018cf316547b2879d9a2dd76a4b80c"><td class="memTemplItemLeft" align="right" valign="top">T::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a4f018cf316547b2879d9a2dd76a4b80c">convolve</a> (double beta, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic, T const &amp;fc, T const &amp;gc, bool time_order=false) const</td></tr>
<tr class="memdesc:a4f018cf316547b2879d9a2dd76a4b80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convolution of two imaginary time Green's functions.  <br /></td></tr>
<tr class="separator:a4f018cf316547b2879d9a2dd76a4b80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b3e21ae66c97691a4580335795f77f" id="r_a87b3e21ae66c97691a4580335795f77f"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryMatrix Tf, nda::MemoryArray Tg, nda::Scalar Sf = nda::get_value_t&lt;Tf&gt;, nda::Scalar Sg = nda::get_value_t&lt;Tg&gt;, nda::Scalar S = typename std::common_type&lt;Sf, Sg&gt;::type&gt; </td></tr>
<tr class="memitem:a87b3e21ae66c97691a4580335795f77f"><td class="memTemplItemLeft" align="right" valign="top">Tg::regular_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a87b3e21ae66c97691a4580335795f77f">convolve</a> (Tf const &amp;fconv, Tg const &amp;g) const</td></tr>
<tr class="memdesc:a87b3e21ae66c97691a4580335795f77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convolution of two imaginary time Green's functions, given matrix of convolution by one of them.  <br /></td></tr>
<tr class="separator:a87b3e21ae66c97691a4580335795f77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0a93f188f4522b2389e9a7fcbf9783" id="r_a6c0a93f188f4522b2389e9a7fcbf9783"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6c0a93f188f4522b2389e9a7fcbf9783"><td class="memTemplItemLeft" align="right" valign="top">nda::matrix&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a6c0a93f188f4522b2389e9a7fcbf9783">convmat</a> (double beta, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic, T const &amp;fc, bool time_order=false) const</td></tr>
<tr class="memdesc:a6c0a93f188f4522b2389e9a7fcbf9783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix of convolution by an imaginary time Green's function.  <br /></td></tr>
<tr class="separator:a6c0a93f188f4522b2389e9a7fcbf9783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f48c8e4b3164985af73fba0fd28b002" id="r_a9f48c8e4b3164985af73fba0fd28b002"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a9f48c8e4b3164985af73fba0fd28b002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a9f48c8e4b3164985af73fba0fd28b002">convmat_inplace</a> (nda::matrix_view&lt; S, nda::C_layout &gt; fconv, double beta, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic, T const &amp;fc, bool time_order=false) const</td></tr>
<tr class="memdesc:a9f48c8e4b3164985af73fba0fd28b002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix of convolution by an imaginary time Green's function in place.  <br /></td></tr>
<tr class="separator:a9f48c8e4b3164985af73fba0fd28b002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa4303e1ee0897417308f380bb75de8" id="r_aaaa4303e1ee0897417308f380bb75de8"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aaaa4303e1ee0897417308f380bb75de8"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#aaaa4303e1ee0897417308f380bb75de8">innerprod</a> (T const &amp;fc, T const &amp;gc) const</td></tr>
<tr class="memdesc:aaaa4303e1ee0897417308f380bb75de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inner product of two imaginary time Green's functions.  <br /></td></tr>
<tr class="separator:aaaa4303e1ee0897417308f380bb75de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20e69067cc04e37fe8448e8d1088776" id="r_ae20e69067cc04e37fe8448e8d1088776"><td class="memItemLeft" align="right" valign="top">nda::vector_const_view&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#ae20e69067cc04e37fe8448e8d1088776">get_itnodes</a> () const</td></tr>
<tr class="memdesc:ae20e69067cc04e37fe8448e8d1088776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DLR imaginary time nodes.  <br /></td></tr>
<tr class="separator:ae20e69067cc04e37fe8448e8d1088776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1395480d77a2f400b62171e553b0f4" id="r_aec1395480d77a2f400b62171e553b0f4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#aec1395480d77a2f400b62171e553b0f4">get_itnodes</a> (int i) const</td></tr>
<tr class="separator:aec1395480d77a2f400b62171e553b0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f9dc847c716f5d8b0ea92d56777263" id="r_ae5f9dc847c716f5d8b0ea92d56777263"><td class="memItemLeft" align="right" valign="top">nda::vector_const_view&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#ae5f9dc847c716f5d8b0ea92d56777263">get_rfnodes</a> () const</td></tr>
<tr class="memdesc:ae5f9dc847c716f5d8b0ea92d56777263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DLR real frequency nodes.  <br /></td></tr>
<tr class="separator:ae5f9dc847c716f5d8b0ea92d56777263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58745b133d7a289d897c920ee89f671" id="r_ac58745b133d7a289d897c920ee89f671"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#ac58745b133d7a289d897c920ee89f671">get_rfnodes</a> (int i) const</td></tr>
<tr class="separator:ac58745b133d7a289d897c920ee89f671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb8521ca54bb5efa1464693679185ba" id="r_a6cb8521ca54bb5efa1464693679185ba"><td class="memItemLeft" align="right" valign="top">nda::matrix_const_view&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a6cb8521ca54bb5efa1464693679185ba">get_cf2it</a> () const</td></tr>
<tr class="memdesc:a6cb8521ca54bb5efa1464693679185ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get transformation matrix from DLR coefficients to values at DLR imaginary time nodes.  <br /></td></tr>
<tr class="separator:a6cb8521ca54bb5efa1464693679185ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44acd4cd20cbe95632534891644f1806" id="r_a44acd4cd20cbe95632534891644f1806"><td class="memItemLeft" align="right" valign="top">nda::matrix_const_view&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a44acd4cd20cbe95632534891644f1806">get_it2cf_lu</a> () const</td></tr>
<tr class="memdesc:a44acd4cd20cbe95632534891644f1806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LU factors of transformation matrix from DLR imaginary time values to coefficients.  <br /></td></tr>
<tr class="separator:a44acd4cd20cbe95632534891644f1806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6caeb28e5c8152483d3c133b047b6fe" id="r_aa6caeb28e5c8152483d3c133b047b6fe"><td class="memItemLeft" align="right" valign="top">nda::matrix_const_view&lt; <a class="el" href="namespacecppdlr.html#a7b5392bb6f0a8155f1f19cab3bd042e9">dcomplex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#aa6caeb28e5c8152483d3c133b047b6fe">get_it2cf_zlu</a> () const</td></tr>
<tr class="memdesc:aa6caeb28e5c8152483d3c133b047b6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LU factors of transformation matrix from DLR imaginary time values to coefficients, cast to complex.  <br /></td></tr>
<tr class="separator:aa6caeb28e5c8152483d3c133b047b6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d6669d27cdd0f51d74fa2d7b2885de" id="r_a44d6669d27cdd0f51d74fa2d7b2885de"><td class="memItemLeft" align="right" valign="top">nda::vector_const_view&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a44d6669d27cdd0f51d74fa2d7b2885de">get_it2cf_piv</a> () const</td></tr>
<tr class="memdesc:a44d6669d27cdd0f51d74fa2d7b2885de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LU pivots of transformation matrix from DLR imaginary time values to coefficients.  <br /></td></tr>
<tr class="separator:a44d6669d27cdd0f51d74fa2d7b2885de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f437cb31c98929ab8a1e6dadb174aa" id="r_a88f437cb31c98929ab8a1e6dadb174aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a88f437cb31c98929ab8a1e6dadb174aa">rank</a> () const</td></tr>
<tr class="memdesc:a88f437cb31c98929ab8a1e6dadb174aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DLR rank.  <br /></td></tr>
<tr class="separator:a88f437cb31c98929ab8a1e6dadb174aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401521dedc309ca12c1ec345da983c80" id="r_a401521dedc309ca12c1ec345da983c80"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a401521dedc309ca12c1ec345da983c80">lambda</a> () const</td></tr>
<tr class="separator:a401521dedc309ca12c1ec345da983c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9211118869fa15b9d1e3092d97b716" id="r_a2c9211118869fa15b9d1e3092d97b716"><td class="memItemLeft" align="right" valign="top">nda::matrix_const_view&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a2c9211118869fa15b9d1e3092d97b716">get_ipmat</a> () const</td></tr>
<tr class="memdesc:a2c9211118869fa15b9d1e3092d97b716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner product matrix.  <br /></td></tr>
<tr class="separator:a2c9211118869fa15b9d1e3092d97b716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6257e0b3f43733c5ac06c8af11a47bb3" id="r_a6257e0b3f43733c5ac06c8af11a47bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a6257e0b3f43733c5ac06c8af11a47bb3">convolve_init</a> () const</td></tr>
<tr class="memdesc:a6257e0b3f43733c5ac06c8af11a47bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for convolution methods.  <br /></td></tr>
<tr class="separator:a6257e0b3f43733c5ac06c8af11a47bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6116f42e1f17050404974d0d6d3d226" id="r_ae6116f42e1f17050404974d0d6d3d226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#ae6116f42e1f17050404974d0d6d3d226">tconvolve_init</a> () const</td></tr>
<tr class="memdesc:ae6116f42e1f17050404974d0d6d3d226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for time-ordered convolution methods.  <br /></td></tr>
<tr class="separator:ae6116f42e1f17050404974d0d6d3d226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce574cd38bdb5bee21d499710f2e8fa" id="r_a6ce574cd38bdb5bee21d499710f2e8fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a6ce574cd38bdb5bee21d499710f2e8fa">innerprod_init</a> () const</td></tr>
<tr class="memdesc:a6ce574cd38bdb5bee21d499710f2e8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for inner product method.  <br /></td></tr>
<tr class="separator:a6ce574cd38bdb5bee21d499710f2e8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a47942235e7330cc6d392dc881d256f" id="r_a3a47942235e7330cc6d392dc881d256f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a3a47942235e7330cc6d392dc881d256f">reflect_init</a> () const</td></tr>
<tr class="memdesc:a3a47942235e7330cc6d392dc881d256f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for reflection method.  <br /></td></tr>
<tr class="separator:a3a47942235e7330cc6d392dc881d256f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af958ce61d0c823b2a356b13c3fa10f3d" id="r_af958ce61d0c823b2a356b13c3fa10f3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#af958ce61d0c823b2a356b13c3fa10f3d">serialize</a> (auto &amp;ar) const</td></tr>
<tr class="separator:af958ce61d0c823b2a356b13c3fa10f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5610238537886bb0c62c52c023f7b8" id="r_aec5610238537886bb0c62c52c023f7b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#aec5610238537886bb0c62c52c023f7b8">deserialize</a> (auto &amp;ar)</td></tr>
<tr class="separator:aec5610238537886bb0c62c52c023f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a649d9f6c3d257661818c3f473f49f57a" id="r_a649d9f6c3d257661818c3f473f49f57a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a649d9f6c3d257661818c3f473f49f57a">hdf5_format</a> ()</td></tr>
<tr class="separator:a649d9f6c3d257661818c3f473f49f57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0eec6aaaea35d7bba7e92951a0de76db" id="r_a0eec6aaaea35d7bba7e92951a0de76db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a0eec6aaaea35d7bba7e92951a0de76db">h5_write</a> (h5::group fg, std::string const &amp;subgroup_name, <a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;m)</td></tr>
<tr class="separator:a0eec6aaaea35d7bba7e92951a0de76db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e5f8519e54734a74b94226d10e082d" id="r_a02e5f8519e54734a74b94226d10e082d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html#a02e5f8519e54734a74b94226d10e082d">h5_read</a> (h5::group fg, std::string const &amp;subgroup_name, <a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> &amp;m)</td></tr>
<tr class="separator:a02e5f8519e54734a74b94226d10e082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations. </p>
<dl class="section note"><dt>Note</dt><dd>First dimension of all Green's function and coefficient arrays must be DLR rank r. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a31b2703038bafa04b59e3731ab0bf234" name="a31b2703038bafa04b59e3731ab0bf234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b2703038bafa04b59e3731ab0bf234">&#9670;&#160;</a></span>imtime_ops() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cppdlr::imtime_ops::imtime_ops </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>dlr_rf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetrize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>DLR cutoff parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dlr_rf</td><td>DLR frequencies </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmetrize</td><td>NONSYM or false for non-symmetrized DLR frequencies, SYM or true for symmetrized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7" name="a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7">&#9670;&#160;</a></span>imtime_ops() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cppdlr::imtime_ops::imtime_ops </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>dlr_rf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>DLR cutoff parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dlr_rf</td><td>DLR frequencies </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43a9b5fb6aeefad7d8ae6865329e69de" name="a43a9b5fb6aeefad7d8ae6865329e69de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a9b5fb6aeefad7d8ae6865329e69de">&#9670;&#160;</a></span>imtime_ops() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cppdlr::imtime_ops::imtime_ops </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>dlr_rf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>dlr_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::matrix_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>cf2it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::matrix_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>it2cf_lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; int &gt;&#160;</td>
          <td class="paramname"><em>it2cf_piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8da78cf54d39d48d2be19ad1f146b03c" name="a8da78cf54d39d48d2be19ad1f146b03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da78cf54d39d48d2be19ad1f146b03c">&#9670;&#160;</a></span>imtime_ops() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cppdlr::imtime_ops::imtime_ops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a318b0b4409d0488814bb8db12c8b0611" name="a318b0b4409d0488814bb8db12c8b0611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318b0b4409d0488814bb8db12c8b0611">&#9670;&#160;</a></span>build_evalvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::imtime_ops::build_evalvec </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build vector of evaluation of DLR expansion at an imaginary time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Evaluation point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of evaluation at <code>t</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The given evaluation point must be scaled to the interval [0, 1] (rather than [0, beta]) and then given in the relative time format. Please see the "Imaginary time point format" section in the Background page of the documentation for more information. </dd></dl>

</div>
</div>
<a id="a12761a877407fc347dc695da4b2d7f3d" name="a12761a877407fc347dc695da4b2d7f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12761a877407fc347dc695da4b2d7f3d">&#9670;&#160;</a></span>coefs2eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto cppdlr::imtime_ops::coefs2eval </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate DLR expansion of G, given by its DLR coefficients, at imaginary time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gc</td><td>DLR coefficients of G </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Evaluation point, in relative format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of G at <code>t</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The given evaluation point must be scaled to the interval [0, 1] (rather than [0, beta]) and then given in the relative time format. Please see the "Imaginary time point format" section in the Background page of the documentation for more information. </dd></dl>

</div>
</div>
<a id="a6f6d71c061aec134df9edf1255e19dfb" name="a6f6d71c061aec134df9edf1255e19dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6d71c061aec134df9edf1255e19dfb">&#9670;&#160;</a></span>coefs2vals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::coefs2vals </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>gc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform DLR coefficients of Green's function G to values on DLR imaginary time grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gc</td><td>DLR coefficients of G</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values of G on DLR imaginary time grid </dd></dl>

</div>
</div>
<a id="a6c0a93f188f4522b2389e9a7fcbf9783" name="a6c0a93f188f4522b2389e9a7fcbf9783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0a93f188f4522b2389e9a7fcbf9783">&#9670;&#160;</a></span>convmat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt; S &gt; cppdlr::imtime_ops::convmat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>time_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute matrix of convolution by an imaginary time Green's function. </p>
<p>The convolution of f and g is defined as h(t) = (f * g)(t) = int_0^beta f(t-t') g(t') dt', where fermionic/bosonic antiperiodicity/periodicity are used to define the Green's functions on (-beta, 0). This method takes the DLR coefficients of f as input and returns the matrix of convolution by f. This matrix can be applied to the values of g on the DLR imaginary time grid, to produce the values of h on the DLR imaginary time grid.</p>
<p>By specifying the <code>time_order</code> flag, this method can be used to compute the time-ordered convolution of f and g, defined as h(t) = (f * g)(t) = int_0^tau f(t-t') g(t') dt'.</p>
<p>The convolution matrix is constructed using the method described in Appendix A of</p>
<p>J. Kaye, H. U. R. Strand, D. Golez, "Decomposing imaginary time Feynman
diagrams using separable basis functions: Anderson impurity model strong
coupling expansion," arXiv:2307.08566 (2023).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Fermionic ("Fermion" or 0) or bosonic ("Boson" or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc</td><td>DLR coefficients of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY, default) or time-ordered (true or TIME_ORDERED) convolution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of convolution by f</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whereas the method <a class="el" href="classcppdlr_1_1imtime__ops.html#a4f018cf316547b2879d9a2dd76a4b80c" title="Compute convolution of two imaginary time Green&#39;s functions.">imtime_ops::convolve</a> takes the DLR coefficients of f and g as input and computes their convolution h directly, this method returns a matrix which should be applied to the DLR imaginary time grid values of g, rather than its DLR coefficients, in to order to obtain the convolution h. The purpose of this is to make the input and output representations of the convolution matrix equal, which is often convenient in practice.</dd>
<dd>
In the case of matrix-valued Green's functions, we think of the matrix of convolution by f as an r*norb x r*norb matrix, or a block r x r matrix of norb x norb blocks. Here r is the DLR rank and norb is the number of orbital indices. This matrix would then be applied to a Green's function g, represented as an r*norb x norb matrix, or a block r x 1 matrix of norb x norb blocks. </dd></dl>

</div>
</div>
<a id="a9f48c8e4b3164985af73fba0fd28b002" name="a9f48c8e4b3164985af73fba0fd28b002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f48c8e4b3164985af73fba0fd28b002">&#9670;&#160;</a></span>convmat_inplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::convmat_inplace </td>
          <td>(</td>
          <td class="paramtype">nda::matrix_view&lt; S, nda::C_layout &gt;&#160;</td>
          <td class="paramname"><em>fconv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>time_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute matrix of convolution by an imaginary time Green's function in place. </p>
<p>The convolution of f and g is defined as h(t) = (f * g)(t) = int_0^beta f(t-t') g(t') dt', where fermionic/bosonic antiperiodicity/periodicity are used to define the Green's functions on (-beta, 0). This method takes the DLR coefficients of f as input and returns the matrix of convolution by f. This matrix can be applied to the values of g on the DLR imaginary time grid, to produce the values of h on the DLR imaginary time grid.</p>
<p>By specifying the <code>time_order</code> flag, this method can be used to compute the time-ordered convolution of f and g, defined as h(t) = (f * g)(t) = int_0^tau f(t-t') g(t') dt'.</p>
<p>The convolution matrix is constructed using the method described in Appendix A of</p>
<p>J. Kaye, H. U. R. Strand, D. Golez, "Decomposing imaginary time Feynman
diagrams using separable basis functions: Anderson impurity model strong
coupling expansion," arXiv:2307.08566 (2023).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>fconv Convolution matrix from DLR coefficients to DLR grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Fermionic ("Fermion" or 0) or bosonic ("Boson" or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc</td><td>DLR coefficients of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY, default) or time-ordered (true or TIME_ORDERED) convolution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function builds the matrix of convolution, in place, in the provided matrix <code>fconv</code>. This makes it possible to control the memory allocation externally. If this is not a concern, we advise using the <code>convmat(...)</code> function instead of <code>convmat_inplace(...)</code>.</dd>
<dd>
Whereas the method <a class="el" href="classcppdlr_1_1imtime__ops.html#a4f018cf316547b2879d9a2dd76a4b80c" title="Compute convolution of two imaginary time Green&#39;s functions.">imtime_ops::convolve</a> takes the DLR coefficients of f and g as input and computes their convolution h directly, this method returns a matrix which should be applied to the DLR imaginary time grid values of g, rather than its DLR coefficients, in to order to obtain the convolution h. The purpose of this is to make the input and output representations of the convolution matrix equal, which is often convenient in practice.</dd>
<dd>
In the case of matrix-valued Green's functions, we think of the matrix of convolution by f as an r*norb x r*norb matrix, or a block r x r matrix of norb x norb blocks. Here r is the DLR rank and norb is the number of orbital indices. This matrix would then be applied to a Green's function g, represented as an r*norb x norb matrix, or a block r x 1 matrix of norb x norb blocks. </dd></dl>

</div>
</div>
<a id="a4f018cf316547b2879d9a2dd76a4b80c" name="a4f018cf316547b2879d9a2dd76a4b80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f018cf316547b2879d9a2dd76a4b80c">&#9670;&#160;</a></span>convolve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::convolve </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>time_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute convolution of two imaginary time Green's functions. </p>
<p>The convolution of f and g is defined as h(t) = (f * g)(t) = int_0^beta f(t-t') g(t') dt', where fermionic/bosonic antiperiodicity/periodicity are used to define the Green's functions on (-beta, 0). This method takes the DLR coefficients of f and g as input and returns the values of h on the DLR imaginary time grid.</p>
<p>By specifying the <code>time_order</code> flag, this method can be used to compute the time-ordered convolution of f and g, defined as h(t) = (f * g)(t) = int_0^tau f(t-t') g(t') dt'.</p>
<p>The convolution is computed on-the-fly in O(r^2) operations using the method described in Appendix A of</p>
<p>J. Kaye, H. U. R. Strand, D. Golez, "Decomposing imaginary time Feynman
diagrams using separable basis functions: Anderson impurity model strong
coupling expansion," arXiv:2307.08566 (2023).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Fermionic ("Fermion" or 0) or bosonic ("Boson" or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc</td><td>DLR coefficients of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gc</td><td>DLR coefficients of g </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_order</td><td>Flag for ordinary (false or ORDINARY, default) or time-ordered (true or TIME_ORDERED) convolution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values of h = f * g on DLR imaginary time grid </dd></dl>

</div>
</div>
<a id="a87b3e21ae66c97691a4580335795f77f" name="a87b3e21ae66c97691a4580335795f77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b3e21ae66c97691a4580335795f77f">&#9670;&#160;</a></span>convolve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryMatrix Tf, nda::MemoryArray Tg, nda::Scalar Sf = nda::get_value_t&lt;Tf&gt;, nda::Scalar Sg = nda::get_value_t&lt;Tg&gt;, nda::Scalar S = typename std::common_type&lt;Sf, Sg&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tg::regular_type cppdlr::imtime_ops::convolve </td>
          <td>(</td>
          <td class="paramtype">Tf const &amp;&#160;</td>
          <td class="paramname"><em>fconv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tg const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute convolution of two imaginary time Green's functions, given matrix of convolution by one of them. </p>
<p>The convolution of f and g is defined as h(t) = (f * g)(t) = int_0^beta f(t-t') g(t') dt', where fermionic/bosonic antiperiodicity/periodicity are used to define the Green's functions on (-beta, 0). This method takes the matrix of convolution by f (computed by the convmat method) and the values of g on the DLR imaginary time grid, and returns the values of h on the DLR imaginary time grid</p>
<p>By passing in the matrix of time-ordered convolution by f (computed by the convmat method with the <code>time_order</code> flag set to true, or TIME_ORDERED), this method can be used to compute the time-ordered convolution of f and g, defined as h(t) = (f * g)(t) = int_0^tau f(t-t') g(t') dt'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fconv</td><td>Matrix of convolution by f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Values of g on the DLR imaginary time grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values of h = f * g on DLR imaginary time grid </dd></dl>

</div>
</div>
<a id="a6257e0b3f43733c5ac06c8af11a47bb3" name="a6257e0b3f43733c5ac06c8af11a47bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6257e0b3f43733c5ac06c8af11a47bb3">&#9670;&#160;</a></span>convolve_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::convolve_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization for convolution methods. </p>
<p>Initialize matrices required for the convolution methods. This method is called automatically the first time one of the relevant convolution methods is called, but it may also be called manually to avoid the additional overhead in the first convolution call. </p>

</div>
</div>
<a id="aec5610238537886bb0c62c52c023f7b8" name="aec5610238537886bb0c62c52c023f7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5610238537886bb0c62c52c023f7b8">&#9670;&#160;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::deserialize </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deserialize an object from the archive. This will initialize all members. The archive parameter must support the operator&amp; to deserialize the members in the order they were serialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>Archive to deserialize from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a81a99b2858defa9513a395bd35e2bf" name="a6a81a99b2858defa9513a395bd35e2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a81a99b2858defa9513a395bd35e2bf">&#9670;&#160;</a></span>fitvals2coefs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::fitvals2coefs </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain DLR coefficients of a Green's function G from scattered imaginary time grid by least squares fitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid points at which G is sampled, in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Values of G on grid t</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLR coefficients of G </dd></dl>

</div>
</div>
<a id="a6cb8521ca54bb5efa1464693679185ba" name="a6cb8521ca54bb5efa1464693679185ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb8521ca54bb5efa1464693679185ba">&#9670;&#160;</a></span>get_cf2it()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix_const_view&lt; double &gt; cppdlr::imtime_ops::get_cf2it </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get transformation matrix from DLR coefficients to values at DLR imaginary time nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Transformation matrix </dd></dl>

</div>
</div>
<a id="a2c9211118869fa15b9d1e3092d97b716" name="a2c9211118869fa15b9d1e3092d97b716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9211118869fa15b9d1e3092d97b716">&#9670;&#160;</a></span>get_ipmat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix_const_view&lt; double &gt; cppdlr::imtime_ops::get_ipmat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get inner product matrix. </p>
<p>Given the vector f and g of DLR coefficients of scalar-valued imaginary time functions F and G, respectively, the inner product matrix M gives</p>
<p>f^T M g = 1/beta int_0^beta dt f(t) g(t).</p>
<dl class="section return"><dt>Returns</dt><dd>Inner product matrix </dd></dl>

</div>
</div>
<a id="a44acd4cd20cbe95632534891644f1806" name="a44acd4cd20cbe95632534891644f1806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44acd4cd20cbe95632534891644f1806">&#9670;&#160;</a></span>get_it2cf_lu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix_const_view&lt; double &gt; cppdlr::imtime_ops::get_it2cf_lu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get LU factors of transformation matrix from DLR imaginary time values to coefficients. </p>
<dl class="section return"><dt>Returns</dt><dd>LU factors </dd></dl>

</div>
</div>
<a id="a44d6669d27cdd0f51d74fa2d7b2885de" name="a44d6669d27cdd0f51d74fa2d7b2885de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d6669d27cdd0f51d74fa2d7b2885de">&#9670;&#160;</a></span>get_it2cf_piv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector_const_view&lt; int &gt; cppdlr::imtime_ops::get_it2cf_piv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get LU pivots of transformation matrix from DLR imaginary time values to coefficients. </p>
<dl class="section return"><dt>Returns</dt><dd>LU pivots </dd></dl>

</div>
</div>
<a id="aa6caeb28e5c8152483d3c133b047b6fe" name="aa6caeb28e5c8152483d3c133b047b6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6caeb28e5c8152483d3c133b047b6fe">&#9670;&#160;</a></span>get_it2cf_zlu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix_const_view&lt; <a class="el" href="namespacecppdlr.html#a7b5392bb6f0a8155f1f19cab3bd042e9">dcomplex</a> &gt; cppdlr::imtime_ops::get_it2cf_zlu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get LU factors of transformation matrix from DLR imaginary time values to coefficients, cast to complex. </p>
<dl class="section return"><dt>Returns</dt><dd>LU factors </dd></dl>

</div>
</div>
<a id="ae20e69067cc04e37fe8448e8d1088776" name="ae20e69067cc04e37fe8448e8d1088776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20e69067cc04e37fe8448e8d1088776">&#9670;&#160;</a></span>get_itnodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector_const_view&lt; double &gt; cppdlr::imtime_ops::get_itnodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get DLR imaginary time nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>DLR imaginary time nodes </dd></dl>

</div>
</div>
<a id="aec1395480d77a2f400b62171e553b0f4" name="aec1395480d77a2f400b62171e553b0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1395480d77a2f400b62171e553b0f4">&#9670;&#160;</a></span>get_itnodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::imtime_ops::get_itnodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5f9dc847c716f5d8b0ea92d56777263" name="ae5f9dc847c716f5d8b0ea92d56777263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f9dc847c716f5d8b0ea92d56777263">&#9670;&#160;</a></span>get_rfnodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector_const_view&lt; double &gt; cppdlr::imtime_ops::get_rfnodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get DLR real frequency nodes. </p>
<p>Access DLR imaginary real frequency nodes </p>
<dl class="section return"><dt>Returns</dt><dd>DLR real frequency nodes </dd></dl>

</div>
</div>
<a id="ac58745b133d7a289d897c920ee89f671" name="ac58745b133d7a289d897c920ee89f671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58745b133d7a289d897c920ee89f671">&#9670;&#160;</a></span>get_rfnodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::imtime_ops::get_rfnodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a649d9f6c3d257661818c3f473f49f57a" name="a649d9f6c3d257661818c3f473f49f57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649d9f6c3d257661818c3f473f49f57a">&#9670;&#160;</a></span>hdf5_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string cppdlr::imtime_ops::hdf5_format </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaaa4303e1ee0897417308f380bb75de8" name="aaaa4303e1ee0897417308f380bb75de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa4303e1ee0897417308f380bb75de8">&#9670;&#160;</a></span>innerprod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S cppdlr::imtime_ops::innerprod </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute inner product of two imaginary time Green's functions. </p>
<p>We define the inner product of complex matrix-valued f and g as</p>
<p>(f,g) = 1/beta * sum_{ij} int_0^beta dt conj(f_ij(t)) g_ij(t),</p>
<p>where conj refers to complex conjugation. This method takes the DLR coefficients of f and g as input and returns the inner product.</p>
<p>We use the numerically stable method described in Appendix B of</p>
<p>H. LaBollita, J. Kaye, A. Hampel, "Stabilizing the calculation of the
self-energy in dynamical mean-field theory using constrained residual
minimization," arXiv:2310.01266 (2023).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fc</td><td>DLR coefficients of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gc</td><td>DLR coefficients of g</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inner product of f and g </dd></dl>

</div>
</div>
<a id="a6ce574cd38bdb5bee21d499710f2e8fa" name="a6ce574cd38bdb5bee21d499710f2e8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce574cd38bdb5bee21d499710f2e8fa">&#9670;&#160;</a></span>innerprod_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::innerprod_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization for inner product method. </p>
<p>This method is called automatically the first time the innerprod method is called, but it may also be called manually to avoid the additional overhead in the first inner product call. </p>

</div>
</div>
<a id="a401521dedc309ca12c1ec345da983c80" name="a401521dedc309ca12c1ec345da983c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401521dedc309ca12c1ec345da983c80">&#9670;&#160;</a></span>lambda()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::imtime_ops::lambda </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88f437cb31c98929ab8a1e6dadb174aa" name="a88f437cb31c98929ab8a1e6dadb174aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f437cb31c98929ab8a1e6dadb174aa">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cppdlr::imtime_ops::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get DLR rank. </p>
<dl class="section return"><dt>Returns</dt><dd>DLR rank </dd></dl>

</div>
</div>
<a id="a0ee9bfed6fc9facf2d25cea9868a3af6" name="a0ee9bfed6fc9facf2d25cea9868a3af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee9bfed6fc9facf2d25cea9868a3af6">&#9670;&#160;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::reflect </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute reflection of imaginary time Green's function. </p>
<p>The reflection of g(t) is g(beta - t). This method takes the values of a Green's function g at the DLR imaginary time nodes to the values of its reflection at the DLR imaginary time nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Values of g at DLR imaginary time nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values of g(beta - t) at DLR imaginary time nodes </dd></dl>

</div>
</div>
<a id="a3a47942235e7330cc6d392dc881d256f" name="a3a47942235e7330cc6d392dc881d256f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a47942235e7330cc6d392dc881d256f">&#9670;&#160;</a></span>reflect_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::reflect_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization for reflection method. </p>
<p>Initialize matrix of the reflection G(tau) -&gt; G(beta - tau) acting on the values of the Green's function at the DLR imaginary time nodes. This matrix is required for the reflect method. It is called automatically the first time the reflect method is called, but it may also be called manually to avoid the additional overhead of the first call to reflect. </p>

</div>
</div>
<a id="af958ce61d0c823b2a356b13c3fa10f3d" name="af958ce61d0c823b2a356b13c3fa10f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af958ce61d0c823b2a356b13c3fa10f3d">&#9670;&#160;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::serialize </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serialize the object into an archive by serializing all its members. The archive parameter must support the operator&amp; to serialize each member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>Archive to serialize into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6116f42e1f17050404974d0d6d3d226" name="ae6116f42e1f17050404974d0d6d3d226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6116f42e1f17050404974d0d6d3d226">&#9670;&#160;</a></span>tconvolve_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppdlr::imtime_ops::tconvolve_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization for time-ordered convolution methods. </p>
<p>Initialize matrices required for the time-ordered convolution methods. This method is called automatically the first time one of the relevant time-ordered convolution methods is called, but it may also be called manually to avoid the additional overhead in the first time-ordered convolution call. </p>

</div>
</div>
<a id="af5bafac0dcc76bd713c732a3792c6e0c" name="af5bafac0dcc76bd713c732a3792c6e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bafac0dcc76bd713c732a3792c6e0c">&#9670;&#160;</a></span>vals2coefs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S = nda::get_value_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::regular_type cppdlr::imtime_ops::vals2coefs </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform values of Green's function G on DLR imaginary time grid to DLR coefficients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Values of G on DLR imaginary time grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transpose</td><td>Transpose values -&gt; coefficients transformation (default is false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLR coefficients of G (if transpose = false, as it is by default; otherwise, see note below)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>By setting the optional argument <code>transpose</code> to true, this method applies the transpose of the values -&gt; coefficients transformation. This is useful for constructing matrices of linear operators which act on vectors of DLR grid values, rather than DLR coefficients. As an example, suppose L is a linear functional such that L[G] = c, G is a Green's function and c is a scalar. If gc is the vector of DLR coefficient of G, then we can represent L by a vector l, with entries given by the action of L on the DLR basis functions, and we have l^T * gc = c. Then</dd></dl>
<p>c = l^T * it2cf * g = (it2cf^T * l)^T * g,</p>
<p>where g is the vector of values of G at the DLR nodes, and it2cf is the imaginary time values -&gt; coefficients matrix. Thus it2cf^T * l is the vector of the linear operator T acting on the vector of values of G at the DLR nodes, and can be precomputed using the vals2coefs method with the transpose option set to true. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a02e5f8519e54734a74b94226d10e082d" name="a02e5f8519e54734a74b94226d10e082d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e5f8519e54734a74b94226d10e082d">&#9670;&#160;</a></span>h5_read</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void h5_read </td>
          <td>(</td>
          <td class="paramtype">h5::group&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>subgroup_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0eec6aaaea35d7bba7e92951a0de76db" name="a0eec6aaaea35d7bba7e92951a0de76db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eec6aaaea35d7bba7e92951a0de76db">&#9670;&#160;</a></span>h5_write</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void h5_write </td>
          <td>(</td>
          <td class="paramtype">h5::group&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>subgroup_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a83e9085aca345c3bf889ae006f0fdb3d" name="a83e9085aca345c3bf889ae006f0fdb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e9085aca345c3bf889ae006f0fdb3d">&#9670;&#160;</a></span>lu</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt;double&gt; cppdlr::imtime_ops::lu</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU factors (LAPACK format) of imaginary time vals -&gt; coefs matrix. </p>

</div>
</div>
<a id="a7cd0e6b5498400d3afade53a6ebab389" name="a7cd0e6b5498400d3afade53a6ebab389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd0e6b5498400d3afade53a6ebab389">&#9670;&#160;</a></span>piv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt;int&gt; cppdlr::imtime_ops::piv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU pivots (LAPACK format) of imaginary time vals -&gt; coefs matrix. </p>

</div>
</div>
<a id="a4868c3d774292b4d3610ac3225682bc0" name="a4868c3d774292b4d3610ac3225682bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4868c3d774292b4d3610ac3225682bc0">&#9670;&#160;</a></span>zlu</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt;<a class="el" href="namespacecppdlr.html#a7b5392bb6f0a8155f1f19cab3bd042e9">dcomplex</a>&gt; cppdlr::imtime_ops::zlu</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as lu, cast to complex (for use with lapack::getrs w/ cmplx input) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/cppdlr/cppdlr/c++/cppdlr/<a class="el" href="dlr__imtime_8hpp_source.html">dlr_imtime.hpp</a></li>
<li>/home/runner/work/cppdlr/cppdlr/c++/cppdlr/<a class="el" href="dlr__imtime_8cpp.html">dlr_imtime.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
