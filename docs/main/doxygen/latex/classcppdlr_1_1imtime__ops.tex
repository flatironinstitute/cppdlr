\hypertarget{classcppdlr_1_1imtime__ops}{}\doxysection{cppdlr\+::imtime\+\_\+ops Class Reference}
\label{classcppdlr_1_1imtime__ops}\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}


Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations.  




{\ttfamily \#include $<$dlr\+\_\+imtime.\+hpp$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classcppdlr_1_1imtime__ops_a31b2703038bafa04b59e3731ab0bf234}{imtime\+\_\+ops}} (double \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a401521dedc309ca12c1ec345da983c80}{lambda}}, nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ dlr\+\_\+rf, bool symmetrize)
\begin{DoxyCompactList}\small\item\em Constructor for \mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcppdlr_1_1imtime__ops_a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7}{imtime\+\_\+ops}} (double \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a401521dedc309ca12c1ec345da983c80}{lambda}}, nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ dlr\+\_\+rf)
\begin{DoxyCompactList}\small\item\em Constructor for \mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcppdlr_1_1imtime__ops_a43a9b5fb6aeefad7d8ae6865329e69de}{imtime\+\_\+ops}} (double \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a401521dedc309ca12c1ec345da983c80}{lambda}}, nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ dlr\+\_\+rf, nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ dlr\+\_\+it, nda\+::matrix\+\_\+const\+\_\+view$<$ double $>$ cf2it, nda\+::matrix\+\_\+const\+\_\+view$<$ double $>$ it2cf\+\_\+lu, nda\+::vector\+\_\+const\+\_\+view$<$ int $>$ it2cf\+\_\+piv)
\item 
\mbox{\hyperlink{classcppdlr_1_1imtime__ops_a8da78cf54d39d48d2be19ad1f146b03c}{imtime\+\_\+ops}} ()=default
\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ }\\T\+::regular\+\_\+type \mbox{\hyperlink{classcppdlr_1_1imtime__ops_af5bafac0dcc76bd713c732a3792c6e0c}{vals2coefs}} (T const \&g, bool transpose=false) const
\begin{DoxyCompactList}\small\item\em Transform values of Green\textquotesingle{}s function G on DLR imaginary time grid to DLR coefficients. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ }\\T\+::regular\+\_\+type \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a6f6d71c061aec134df9edf1255e19dfb}{coefs2vals}} (T const \&gc) const
\begin{DoxyCompactList}\small\item\em Transform DLR coefficients of Green\textquotesingle{}s function G to values on DLR imaginary time grid. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ }\\auto \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a12761a877407fc347dc695da4b2d7f3d}{coefs2eval}} (T const \&gc, double t) const
\begin{DoxyCompactList}\small\item\em Evaluate DLR expansion of G, given by its DLR coefficients, at imaginary time point. \end{DoxyCompactList}\item 
nda\+::vector$<$ double $>$ \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a318b0b4409d0488814bb8db12c8b0611}{build\+\_\+evalvec}} (double t) const
\begin{DoxyCompactList}\small\item\em Build vector of evaluation of DLR expansion at an imaginary time point. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ }\\T\+::regular\+\_\+type \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a6a81a99b2858defa9513a395bd35e2bf}{fitvals2coefs}} (nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ t, T const \&g) const
\begin{DoxyCompactList}\small\item\em Obtain DLR coefficients of a Green\textquotesingle{}s function G from scattered imaginary time grid by least squares fitting. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T$>$ }\\T\+::regular\+\_\+type \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a0ee9bfed6fc9facf2d25cea9868a3af6}{reflect}} (T const \&g) const
\begin{DoxyCompactList}\small\item\em Compute reflection of imaginary time Green\textquotesingle{}s function. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ }\\T\+::regular\+\_\+type \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a4f018cf316547b2879d9a2dd76a4b80c}{convolve}} (double beta, \mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}} statistic, T const \&fc, T const \&gc, bool \mbox{\hyperlink{namespacecppdlr_afef0a162a809071b83fd09f578db52bf}{time\+\_\+order}}=false) const
\begin{DoxyCompactList}\small\item\em Compute convolution of two imaginary time Green\textquotesingle{}s functions. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Matrix Tf, nda\+::\+Memory\+Array Tg, nda\+::\+Scalar Sf = nda\+::get\+\_\+value\+\_\+t$<$\+Tf$>$, nda\+::\+Scalar Sg = nda\+::get\+\_\+value\+\_\+t$<$\+Tg$>$, nda\+::\+Scalar S = typename std\+::common\+\_\+type$<$\+Sf, Sg$>$\+::type$>$ }\\Tg\+::regular\+\_\+type \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a87b3e21ae66c97691a4580335795f77f}{convolve}} (Tf const \&fconv, Tg const \&g) const
\begin{DoxyCompactList}\small\item\em Compute convolution of two imaginary time Green\textquotesingle{}s functions, given matrix of convolution by one of them. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ }\\nda\+::matrix$<$ S $>$ \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a4b0899c199459a76210d535eab89fd3a}{convmat}} (double beta, \mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}} statistic, T const \&fc, bool \mbox{\hyperlink{namespacecppdlr_afef0a162a809071b83fd09f578db52bf}{time\+\_\+order}}=false) const
\begin{DoxyCompactList}\small\item\em Compute matrix of convolution by an imaginary time Green\textquotesingle{}s function. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ }\\S \mbox{\hyperlink{classcppdlr_1_1imtime__ops_aaaa4303e1ee0897417308f380bb75de8}{innerprod}} (T const \&fc, T const \&gc) const
\begin{DoxyCompactList}\small\item\em Compute inner product of two imaginary time Green\textquotesingle{}s functions. \end{DoxyCompactList}\item 
nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a89451028e273c8753d87621081a16cee}{get\+\_\+itnodes}} () const
\begin{DoxyCompactList}\small\item\em Get DLR imaginary time nodes. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classcppdlr_1_1imtime__ops_aec1395480d77a2f400b62171e553b0f4}{get\+\_\+itnodes}} (int i) const
\item 
nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a369d8d83b9ed6c31d8c34784d162f389}{get\+\_\+rfnodes}} () const
\begin{DoxyCompactList}\small\item\em Get DLR real frequency nodes. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classcppdlr_1_1imtime__ops_ac58745b133d7a289d897c920ee89f671}{get\+\_\+rfnodes}} (int i) const
\item 
nda\+::matrix\+\_\+const\+\_\+view$<$ double $>$ \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a278304f50e778063a60df49be4d89909}{get\+\_\+cf2it}} () const
\begin{DoxyCompactList}\small\item\em Get transformation matrix from DLR coefficients to values at DLR imaginary time nodes. \end{DoxyCompactList}\item 
nda\+::matrix\+\_\+const\+\_\+view$<$ double $>$ \mbox{\hyperlink{classcppdlr_1_1imtime__ops_af2b17e780b762dde6a25d8f8e844dab3}{get\+\_\+it2cf\+\_\+lu}} () const
\begin{DoxyCompactList}\small\item\em Get LU factors of transformation matrix from DLR imaginary time values to coefficients. \end{DoxyCompactList}\item 
nda\+::matrix\+\_\+const\+\_\+view$<$ dcomplex $>$ \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a348fcd0b23b228a73b29c1507c27d589}{get\+\_\+it2cf\+\_\+zlu}} () const
\begin{DoxyCompactList}\small\item\em Get LU factors of transformation matrix from DLR imaginary time values to coefficients, cast to complex. \end{DoxyCompactList}\item 
nda\+::vector\+\_\+const\+\_\+view$<$ int $>$ \mbox{\hyperlink{classcppdlr_1_1imtime__ops_acc0575ff4a9de9b9c6c186b9f002cc53}{get\+\_\+it2cf\+\_\+piv}} () const
\begin{DoxyCompactList}\small\item\em Get LU pivots of transformation matrix from DLR imaginary time values to coefficients. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a88f437cb31c98929ab8a1e6dadb174aa}{rank}} () const
\begin{DoxyCompactList}\small\item\em Get DLR rank. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a401521dedc309ca12c1ec345da983c80}{lambda}} () const
\item 
nda\+::matrix\+\_\+const\+\_\+view$<$ double $>$ \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a6c1c9607902f7f82d93ea8710efc9882}{get\+\_\+ipmat}} () const
\begin{DoxyCompactList}\small\item\em Get inner product matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a6257e0b3f43733c5ac06c8af11a47bb3}{convolve\+\_\+init}} () const
\begin{DoxyCompactList}\small\item\em Initialization for convolution methods. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classcppdlr_1_1imtime__ops_ae6116f42e1f17050404974d0d6d3d226}{tconvolve\+\_\+init}} () const
\begin{DoxyCompactList}\small\item\em Initialization for time-\/ordered convolution methods. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a6ce574cd38bdb5bee21d499710f2e8fa}{innerprod\+\_\+init}} () const
\begin{DoxyCompactList}\small\item\em Initialization for inner product method. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a3a47942235e7330cc6d392dc881d256f}{reflect\+\_\+init}} () const
\begin{DoxyCompactList}\small\item\em Initialization for reflection method. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classcppdlr_1_1imtime__ops_af958ce61d0c823b2a356b13c3fa10f3d}{serialize}} (auto \&ar) const
\item 
void \mbox{\hyperlink{classcppdlr_1_1imtime__ops_aec5610238537886bb0c62c52c023f7b8}{deserialize}} (auto \&ar)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::string \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a649d9f6c3d257661818c3f473f49f57a}{hdf5\+\_\+format}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a0eec6aaaea35d7bba7e92951a0de76db}{h5\+\_\+write}} (h5\+::group fg, std\+::string const \&subgroup\+\_\+name, \mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}} const \&m)
\item 
void \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a02e5f8519e54734a74b94226d10e082d}{h5\+\_\+read}} (h5\+::group fg, std\+::string const \&subgroup\+\_\+name, \mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}} \&m)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations. 

\begin{DoxyNote}{Note}
First dimension of all Green\textquotesingle{}s function and coefficient arrays must be DLR rank r. 
\end{DoxyNote}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a31b2703038bafa04b59e3731ab0bf234}\label{classcppdlr_1_1imtime__ops_a31b2703038bafa04b59e3731ab0bf234}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!imtime\_ops@{imtime\_ops}}
\index{imtime\_ops@{imtime\_ops}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{imtime\_ops()}{imtime\_ops()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily cppdlr\+::imtime\+\_\+ops\+::imtime\+\_\+ops (\begin{DoxyParamCaption}\item[{double}]{lambda,  }\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{dlr\+\_\+rf,  }\item[{bool}]{symmetrize }\end{DoxyParamCaption})}



Constructor for \mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em lambda} & DLR cutoff parameter \\
\hline
\mbox{\texttt{ in}}  & {\em dlr\+\_\+rf} & DLR frequencies \\
\hline
\mbox{\texttt{ in}}  & {\em symmetrize} & NONSYM or false for non-\/symmetrized DLR frequencies, SYM or true for symmetrized \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7}\label{classcppdlr_1_1imtime__ops_a0a1d4dfc2eb1ebc6fbd4cf6b9c13b2d7}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!imtime\_ops@{imtime\_ops}}
\index{imtime\_ops@{imtime\_ops}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{imtime\_ops()}{imtime\_ops()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily cppdlr\+::imtime\+\_\+ops\+::imtime\+\_\+ops (\begin{DoxyParamCaption}\item[{double}]{lambda,  }\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{dlr\+\_\+rf }\end{DoxyParamCaption})}



Constructor for \mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em lambda} & DLR cutoff parameter \\
\hline
\mbox{\texttt{ in}}  & {\em dlr\+\_\+rf} & DLR frequencies \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a43a9b5fb6aeefad7d8ae6865329e69de}\label{classcppdlr_1_1imtime__ops_a43a9b5fb6aeefad7d8ae6865329e69de}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!imtime\_ops@{imtime\_ops}}
\index{imtime\_ops@{imtime\_ops}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{imtime\_ops()}{imtime\_ops()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily cppdlr\+::imtime\+\_\+ops\+::imtime\+\_\+ops (\begin{DoxyParamCaption}\item[{double}]{lambda,  }\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{dlr\+\_\+rf,  }\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{dlr\+\_\+it,  }\item[{nda\+::matrix\+\_\+const\+\_\+view$<$ double $>$}]{cf2it,  }\item[{nda\+::matrix\+\_\+const\+\_\+view$<$ double $>$}]{it2cf\+\_\+lu,  }\item[{nda\+::vector\+\_\+const\+\_\+view$<$ int $>$}]{it2cf\+\_\+piv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a8da78cf54d39d48d2be19ad1f146b03c}\label{classcppdlr_1_1imtime__ops_a8da78cf54d39d48d2be19ad1f146b03c}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!imtime\_ops@{imtime\_ops}}
\index{imtime\_ops@{imtime\_ops}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{imtime\_ops()}{imtime\_ops()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily cppdlr\+::imtime\+\_\+ops\+::imtime\+\_\+ops (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a318b0b4409d0488814bb8db12c8b0611}\label{classcppdlr_1_1imtime__ops_a318b0b4409d0488814bb8db12c8b0611}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!build\_evalvec@{build\_evalvec}}
\index{build\_evalvec@{build\_evalvec}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{build\_evalvec()}{build\_evalvec()}}
{\footnotesize\ttfamily nda\+::vector$<$ double $>$ cppdlr\+::imtime\+\_\+ops\+::build\+\_\+evalvec (\begin{DoxyParamCaption}\item[{double}]{t }\end{DoxyParamCaption}) const}



Build vector of evaluation of DLR expansion at an imaginary time point. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em t} & Evaluation point\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of evaluation at {\ttfamily t} 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The given evaluation point must be scaled to the interval \mbox{[}0, 1\mbox{]} (rather than \mbox{[}0, beta\mbox{]}) and then given in the relative time format. Please see the \char`\"{}\+Imaginary time point format\char`\"{} section in the Background page of the documentation for more information. 
\end{DoxyNote}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a12761a877407fc347dc695da4b2d7f3d}\label{classcppdlr_1_1imtime__ops_a12761a877407fc347dc695da4b2d7f3d}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!coefs2eval@{coefs2eval}}
\index{coefs2eval@{coefs2eval}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{coefs2eval()}{coefs2eval()}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ \\
auto cppdlr\+::imtime\+\_\+ops\+::coefs2eval (\begin{DoxyParamCaption}\item[{T const \&}]{gc,  }\item[{double}]{t }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Evaluate DLR expansion of G, given by its DLR coefficients, at imaginary time point. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em gc} & DLR coefficients of G \\
\hline
\mbox{\texttt{ in}}  & {\em t} & Evaluation point, in relative format\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value of G at {\ttfamily t} 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The given evaluation point must be scaled to the interval \mbox{[}0, 1\mbox{]} (rather than \mbox{[}0, beta\mbox{]}) and then given in the relative time format. Please see the \char`\"{}\+Imaginary time point format\char`\"{} section in the Background page of the documentation for more information. 
\end{DoxyNote}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a6f6d71c061aec134df9edf1255e19dfb}\label{classcppdlr_1_1imtime__ops_a6f6d71c061aec134df9edf1255e19dfb}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!coefs2vals@{coefs2vals}}
\index{coefs2vals@{coefs2vals}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{coefs2vals()}{coefs2vals()}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ \\
T\+::regular\+\_\+type cppdlr\+::imtime\+\_\+ops\+::coefs2vals (\begin{DoxyParamCaption}\item[{T const \&}]{gc }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Transform DLR coefficients of Green\textquotesingle{}s function G to values on DLR imaginary time grid. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em gc} & DLR coefficients of G\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Values of G on DLR imaginary time grid 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a4b0899c199459a76210d535eab89fd3a}\label{classcppdlr_1_1imtime__ops_a4b0899c199459a76210d535eab89fd3a}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!convmat@{convmat}}
\index{convmat@{convmat}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{convmat()}{convmat()}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ \\
nda\+::matrix$<$S$>$ cppdlr\+::imtime\+\_\+ops\+::convmat (\begin{DoxyParamCaption}\item[{double}]{beta,  }\item[{\mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}}}]{statistic,  }\item[{T const \&}]{fc,  }\item[{bool}]{time\+\_\+order = {\ttfamily false} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Compute matrix of convolution by an imaginary time Green\textquotesingle{}s function. 

The convolution of f and g is defined as h(t) = (f $\ast$ g)(t) = int\+\_\+0$^\wedge$beta f(t-\/t\textquotesingle{}) g(t\textquotesingle{}) dt\textquotesingle{}, where fermionic/bosonic antiperiodicity/periodicity are used to define the Green\textquotesingle{}s functions on (-\/beta, 0). This method takes the DLR coefficients of f as input and returns the matrix of convolution by f. This matrix can be applied to the values of g on the DLR imaginary time grid, to produce the values of h on the DLR imaginary time grid.

By specifying the {\ttfamily time\+\_\+order} flag, this method can be used to compute the time-\/ordered convolution of f and g, defined as h(t) = (f $\ast$ g)(t) = int\+\_\+0$^\wedge$tau f(t-\/t\textquotesingle{}) g(t\textquotesingle{}) dt\textquotesingle{}.

The convolution matrix is constructed using the method described in Appendix A of

J. Kaye, H. U. R. Strand, D. Golez, "{}Decomposing imaginary time Feynman diagrams using separable basis functions\+: Anderson impurity model strong coupling expansion,"{} ar\+Xiv\+:2307.\+08566 (2023).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em beta} & Inverse temperature \\
\hline
\mbox{\texttt{ in}}  & {\em statistic} & Fermionic (\char`\"{}\+Fermion\char`\"{} or 0) or bosonic (\char`\"{}\+Boson\char`\"{} or 1) \\
\hline
\mbox{\texttt{ in}}  & {\em fc} & DLR coefficients of f \\
\hline
\mbox{\texttt{ in}}  & {\em time\+\_\+order} & Flag for ordinary (false or ORDINARY, default) or time-\/ordered (true or TIME\+\_\+\+ORDERED) convolution\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Matrix of convolution by f
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Whereas the method \mbox{\hyperlink{classcppdlr_1_1imtime__ops_a4f018cf316547b2879d9a2dd76a4b80c}{imtime\+\_\+ops\+::convolve}} takes the DLR coefficients of f and g as input and computes their convolution h directly, this method returns a matrix which should be applied to the DLR imaginary time grid values of g, rather than its DLR coefficients, in to order to obtain the convolution h. The purpose of this is to make the input and output representations of the convolution matrix equal, which is often convenient in practice.

In the case of matrix-\/valued Green\textquotesingle{}s functions, we think of the matrix of convolution by f as an r$\ast$norb x r$\ast$norb matrix, or a block r x r matrix of norb x norb blocks. Here r is the DLR rank and norb is the number of orbital indices. This matrix would then be applied to a Green\textquotesingle{}s function g, represented as an r$\ast$norb x norb matrix, or a block r x 1 matrix of norb x norb blocks. 
\end{DoxyNote}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a4f018cf316547b2879d9a2dd76a4b80c}\label{classcppdlr_1_1imtime__ops_a4f018cf316547b2879d9a2dd76a4b80c}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!convolve@{convolve}}
\index{convolve@{convolve}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{convolve()}{convolve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ \\
T\+::regular\+\_\+type cppdlr\+::imtime\+\_\+ops\+::convolve (\begin{DoxyParamCaption}\item[{double}]{beta,  }\item[{\mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}}}]{statistic,  }\item[{T const \&}]{fc,  }\item[{T const \&}]{gc,  }\item[{bool}]{time\+\_\+order = {\ttfamily false} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Compute convolution of two imaginary time Green\textquotesingle{}s functions. 

The convolution of f and g is defined as h(t) = (f $\ast$ g)(t) = int\+\_\+0$^\wedge$beta f(t-\/t\textquotesingle{}) g(t\textquotesingle{}) dt\textquotesingle{}, where fermionic/bosonic antiperiodicity/periodicity are used to define the Green\textquotesingle{}s functions on (-\/beta, 0). This method takes the DLR coefficients of f and g as input and returns the values of h on the DLR imaginary time grid.

By specifying the {\ttfamily time\+\_\+order} flag, this method can be used to compute the time-\/ordered convolution of f and g, defined as h(t) = (f $\ast$ g)(t) = int\+\_\+0$^\wedge$tau f(t-\/t\textquotesingle{}) g(t\textquotesingle{}) dt\textquotesingle{}.

The convolution is computed on-\/the-\/fly in O(r$^\wedge$2) operations using the method described in Appendix A of

J. Kaye, H. U. R. Strand, D. Golez, "{}Decomposing imaginary time Feynman diagrams using separable basis functions\+: Anderson impurity model strong coupling expansion,"{} ar\+Xiv\+:2307.\+08566 (2023).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em beta} & Inverse temperature \\
\hline
\mbox{\texttt{ in}}  & {\em statistic} & Fermionic (\char`\"{}\+Fermion\char`\"{} or 0) or bosonic (\char`\"{}\+Boson\char`\"{} or 1) \\
\hline
\mbox{\texttt{ in}}  & {\em fc} & DLR coefficients of f \\
\hline
\mbox{\texttt{ in}}  & {\em gc} & DLR coefficients of g \\
\hline
\mbox{\texttt{ in}}  & {\em time\+\_\+order} & Flag for ordinary (false or ORDINARY, default) or time-\/ordered (true or TIME\+\_\+\+ORDERED) convolution\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Values of h = f $\ast$ g on DLR imaginary time grid 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a87b3e21ae66c97691a4580335795f77f}\label{classcppdlr_1_1imtime__ops_a87b3e21ae66c97691a4580335795f77f}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!convolve@{convolve}}
\index{convolve@{convolve}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{convolve()}{convolve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Matrix Tf, nda\+::\+Memory\+Array Tg, nda\+::\+Scalar Sf = nda\+::get\+\_\+value\+\_\+t$<$\+Tf$>$, nda\+::\+Scalar Sg = nda\+::get\+\_\+value\+\_\+t$<$\+Tg$>$, nda\+::\+Scalar S = typename std\+::common\+\_\+type$<$\+Sf, Sg$>$\+::type$>$ \\
Tg\+::regular\+\_\+type cppdlr\+::imtime\+\_\+ops\+::convolve (\begin{DoxyParamCaption}\item[{Tf const \&}]{fconv,  }\item[{Tg const \&}]{g }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Compute convolution of two imaginary time Green\textquotesingle{}s functions, given matrix of convolution by one of them. 

The convolution of f and g is defined as h(t) = (f $\ast$ g)(t) = int\+\_\+0$^\wedge$beta f(t-\/t\textquotesingle{}) g(t\textquotesingle{}) dt\textquotesingle{}, where fermionic/bosonic antiperiodicity/periodicity are used to define the Green\textquotesingle{}s functions on (-\/beta, 0). This method takes the matrix of convolution by f (computed by the convmat method) and the values of g on the DLR imaginary time grid, and returns the values of h on the DLR imaginary time grid

By passing in the matrix of time-\/ordered convolution by f (computed by the convmat method with the {\ttfamily time\+\_\+order} flag set to true, or TIME\+\_\+\+ORDERED), this method can be used to compute the time-\/ordered convolution of f and g, defined as h(t) = (f $\ast$ g)(t) = int\+\_\+0$^\wedge$tau f(t-\/t\textquotesingle{}) g(t\textquotesingle{}) dt\textquotesingle{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fconv} & Matrix of convolution by f \\
\hline
\mbox{\texttt{ in}}  & {\em g} & Values of g on the DLR imaginary time grid\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Values of h = f $\ast$ g on DLR imaginary time grid 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a6257e0b3f43733c5ac06c8af11a47bb3}\label{classcppdlr_1_1imtime__ops_a6257e0b3f43733c5ac06c8af11a47bb3}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!convolve\_init@{convolve\_init}}
\index{convolve\_init@{convolve\_init}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{convolve\_init()}{convolve\_init()}}
{\footnotesize\ttfamily void cppdlr\+::imtime\+\_\+ops\+::convolve\+\_\+init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Initialization for convolution methods. 

Initialize matrices required for the convolution methods. This method is called automatically the first time one of the relevant convolution methods is called, but it may also be called manually to avoid the additional overhead in the first convolution call. \mbox{\Hypertarget{classcppdlr_1_1imtime__ops_aec5610238537886bb0c62c52c023f7b8}\label{classcppdlr_1_1imtime__ops_aec5610238537886bb0c62c52c023f7b8}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{deserialize()}{deserialize()}}
{\footnotesize\ttfamily void cppdlr\+::imtime\+\_\+ops\+::deserialize (\begin{DoxyParamCaption}\item[{auto \&}]{ar }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Deserialize an object from the archive. This will initialize all members. The archive parameter must support the operator\& to deserialize the members in the order they were serialized.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ar} & Archive to deserialize from \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a6a81a99b2858defa9513a395bd35e2bf}\label{classcppdlr_1_1imtime__ops_a6a81a99b2858defa9513a395bd35e2bf}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!fitvals2coefs@{fitvals2coefs}}
\index{fitvals2coefs@{fitvals2coefs}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{fitvals2coefs()}{fitvals2coefs()}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ \\
T\+::regular\+\_\+type cppdlr\+::imtime\+\_\+ops\+::fitvals2coefs (\begin{DoxyParamCaption}\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{t,  }\item[{T const \&}]{g }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Obtain DLR coefficients of a Green\textquotesingle{}s function G from scattered imaginary time grid by least squares fitting. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em t} & Imaginary time grid points at which G is sampled, in relative format \\
\hline
\mbox{\texttt{ in}}  & {\em g} & Values of G on grid t\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
DLR coefficients of G 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a278304f50e778063a60df49be4d89909}\label{classcppdlr_1_1imtime__ops_a278304f50e778063a60df49be4d89909}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!get\_cf2it@{get\_cf2it}}
\index{get\_cf2it@{get\_cf2it}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{get\_cf2it()}{get\_cf2it()}}
{\footnotesize\ttfamily nda\+::matrix\+\_\+const\+\_\+view$<$double$>$ cppdlr\+::imtime\+\_\+ops\+::get\+\_\+cf2it (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get transformation matrix from DLR coefficients to values at DLR imaginary time nodes. 

\begin{DoxyReturn}{Returns}
Transformation matrix 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a6c1c9607902f7f82d93ea8710efc9882}\label{classcppdlr_1_1imtime__ops_a6c1c9607902f7f82d93ea8710efc9882}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!get\_ipmat@{get\_ipmat}}
\index{get\_ipmat@{get\_ipmat}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{get\_ipmat()}{get\_ipmat()}}
{\footnotesize\ttfamily nda\+::matrix\+\_\+const\+\_\+view$<$double$>$ cppdlr\+::imtime\+\_\+ops\+::get\+\_\+ipmat (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get inner product matrix. 

Given the vector f and g of DLR coefficients of scalar-\/valued imaginary time functions F and G, respectively, the inner product matrix M gives

f$^\wedge$T M g = 1/beta int\+\_\+0$^\wedge$beta dt f(t) g(t).

\begin{DoxyReturn}{Returns}
Inner product matrix 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_af2b17e780b762dde6a25d8f8e844dab3}\label{classcppdlr_1_1imtime__ops_af2b17e780b762dde6a25d8f8e844dab3}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!get\_it2cf\_lu@{get\_it2cf\_lu}}
\index{get\_it2cf\_lu@{get\_it2cf\_lu}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{get\_it2cf\_lu()}{get\_it2cf\_lu()}}
{\footnotesize\ttfamily nda\+::matrix\+\_\+const\+\_\+view$<$double$>$ cppdlr\+::imtime\+\_\+ops\+::get\+\_\+it2cf\+\_\+lu (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get LU factors of transformation matrix from DLR imaginary time values to coefficients. 

\begin{DoxyReturn}{Returns}
LU factors 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_acc0575ff4a9de9b9c6c186b9f002cc53}\label{classcppdlr_1_1imtime__ops_acc0575ff4a9de9b9c6c186b9f002cc53}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!get\_it2cf\_piv@{get\_it2cf\_piv}}
\index{get\_it2cf\_piv@{get\_it2cf\_piv}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{get\_it2cf\_piv()}{get\_it2cf\_piv()}}
{\footnotesize\ttfamily nda\+::vector\+\_\+const\+\_\+view$<$int$>$ cppdlr\+::imtime\+\_\+ops\+::get\+\_\+it2cf\+\_\+piv (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get LU pivots of transformation matrix from DLR imaginary time values to coefficients. 

\begin{DoxyReturn}{Returns}
LU pivots 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a348fcd0b23b228a73b29c1507c27d589}\label{classcppdlr_1_1imtime__ops_a348fcd0b23b228a73b29c1507c27d589}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!get\_it2cf\_zlu@{get\_it2cf\_zlu}}
\index{get\_it2cf\_zlu@{get\_it2cf\_zlu}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{get\_it2cf\_zlu()}{get\_it2cf\_zlu()}}
{\footnotesize\ttfamily nda\+::matrix\+\_\+const\+\_\+view$<$dcomplex$>$ cppdlr\+::imtime\+\_\+ops\+::get\+\_\+it2cf\+\_\+zlu (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get LU factors of transformation matrix from DLR imaginary time values to coefficients, cast to complex. 

\begin{DoxyReturn}{Returns}
LU factors 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a89451028e273c8753d87621081a16cee}\label{classcppdlr_1_1imtime__ops_a89451028e273c8753d87621081a16cee}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!get\_itnodes@{get\_itnodes}}
\index{get\_itnodes@{get\_itnodes}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{get\_itnodes()}{get\_itnodes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily nda\+::vector\+\_\+const\+\_\+view$<$double$>$ cppdlr\+::imtime\+\_\+ops\+::get\+\_\+itnodes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get DLR imaginary time nodes. 

\begin{DoxyReturn}{Returns}
DLR imaginary time nodes 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_aec1395480d77a2f400b62171e553b0f4}\label{classcppdlr_1_1imtime__ops_aec1395480d77a2f400b62171e553b0f4}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!get\_itnodes@{get\_itnodes}}
\index{get\_itnodes@{get\_itnodes}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{get\_itnodes()}{get\_itnodes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double cppdlr\+::imtime\+\_\+ops\+::get\+\_\+itnodes (\begin{DoxyParamCaption}\item[{int}]{i }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a369d8d83b9ed6c31d8c34784d162f389}\label{classcppdlr_1_1imtime__ops_a369d8d83b9ed6c31d8c34784d162f389}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!get\_rfnodes@{get\_rfnodes}}
\index{get\_rfnodes@{get\_rfnodes}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{get\_rfnodes()}{get\_rfnodes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily nda\+::vector\+\_\+const\+\_\+view$<$double$>$ cppdlr\+::imtime\+\_\+ops\+::get\+\_\+rfnodes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get DLR real frequency nodes. 

Access DLR imaginary real frequency nodes

\begin{DoxyReturn}{Returns}
DLR real frequency nodes 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_ac58745b133d7a289d897c920ee89f671}\label{classcppdlr_1_1imtime__ops_ac58745b133d7a289d897c920ee89f671}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!get\_rfnodes@{get\_rfnodes}}
\index{get\_rfnodes@{get\_rfnodes}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{get\_rfnodes()}{get\_rfnodes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double cppdlr\+::imtime\+\_\+ops\+::get\+\_\+rfnodes (\begin{DoxyParamCaption}\item[{int}]{i }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a649d9f6c3d257661818c3f473f49f57a}\label{classcppdlr_1_1imtime__ops_a649d9f6c3d257661818c3f473f49f57a}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!hdf5\_format@{hdf5\_format}}
\index{hdf5\_format@{hdf5\_format}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{hdf5\_format()}{hdf5\_format()}}
{\footnotesize\ttfamily static std\+::string cppdlr\+::imtime\+\_\+ops\+::hdf5\+\_\+format (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_aaaa4303e1ee0897417308f380bb75de8}\label{classcppdlr_1_1imtime__ops_aaaa4303e1ee0897417308f380bb75de8}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!innerprod@{innerprod}}
\index{innerprod@{innerprod}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{innerprod()}{innerprod()}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ \\
S cppdlr\+::imtime\+\_\+ops\+::innerprod (\begin{DoxyParamCaption}\item[{T const \&}]{fc,  }\item[{T const \&}]{gc }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Compute inner product of two imaginary time Green\textquotesingle{}s functions. 

We define the inner product of complex matrix-\/valued f and g as

(f,g) = 1/beta $\ast$ sum\+\_\+\{ij\} int\+\_\+0$^\wedge$beta dt conj(f\+\_\+ij(t)) g\+\_\+ij(t),

where conj refers to complex conjugation. This method takes the DLR coefficients of f and g as input and returns the inner product.

We use the numerically stable method described in Appendix B of

H. La\+Bollita, J. Kaye, A. Hampel, "{}Stabilizing the calculation of the self-\/energy in dynamical mean-\/field theory using constrained residual minimization,"{} ar\+Xiv\+:2310.\+01266 (2023).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fc} & DLR coefficients of f \\
\hline
\mbox{\texttt{ in}}  & {\em gc} & DLR coefficients of g\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Inner product of f and g 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a6ce574cd38bdb5bee21d499710f2e8fa}\label{classcppdlr_1_1imtime__ops_a6ce574cd38bdb5bee21d499710f2e8fa}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!innerprod\_init@{innerprod\_init}}
\index{innerprod\_init@{innerprod\_init}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{innerprod\_init()}{innerprod\_init()}}
{\footnotesize\ttfamily void cppdlr\+::imtime\+\_\+ops\+::innerprod\+\_\+init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Initialization for inner product method. 

This method is called automatically the first time the innerprod method is called, but it may also be called manually to avoid the additional overhead in the first inner product call. \mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a401521dedc309ca12c1ec345da983c80}\label{classcppdlr_1_1imtime__ops_a401521dedc309ca12c1ec345da983c80}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!lambda@{lambda}}
\index{lambda@{lambda}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{lambda()}{lambda()}}
{\footnotesize\ttfamily double cppdlr\+::imtime\+\_\+ops\+::lambda (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a88f437cb31c98929ab8a1e6dadb174aa}\label{classcppdlr_1_1imtime__ops_a88f437cb31c98929ab8a1e6dadb174aa}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!rank@{rank}}
\index{rank@{rank}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{rank()}{rank()}}
{\footnotesize\ttfamily int cppdlr\+::imtime\+\_\+ops\+::rank (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get DLR rank. 

\begin{DoxyReturn}{Returns}
DLR rank 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a0ee9bfed6fc9facf2d25cea9868a3af6}\label{classcppdlr_1_1imtime__ops_a0ee9bfed6fc9facf2d25cea9868a3af6}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!reflect@{reflect}}
\index{reflect@{reflect}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{reflect()}{reflect()}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T$>$ \\
T\+::regular\+\_\+type cppdlr\+::imtime\+\_\+ops\+::reflect (\begin{DoxyParamCaption}\item[{T const \&}]{g }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Compute reflection of imaginary time Green\textquotesingle{}s function. 

The reflection of g(t) is g(beta -\/ t). This method takes the values of a Green\textquotesingle{}s function g at the DLR imaginary time nodes to the values of its reflection at the DLR imaginary time nodes.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em g} & Values of g at DLR imaginary time nodes\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Values of g(beta -\/ t) at DLR imaginary time nodes 
\end{DoxyReturn}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a3a47942235e7330cc6d392dc881d256f}\label{classcppdlr_1_1imtime__ops_a3a47942235e7330cc6d392dc881d256f}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!reflect\_init@{reflect\_init}}
\index{reflect\_init@{reflect\_init}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{reflect\_init()}{reflect\_init()}}
{\footnotesize\ttfamily void cppdlr\+::imtime\+\_\+ops\+::reflect\+\_\+init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Initialization for reflection method. 

Initialize matrix of the reflection G(tau) -\/$>$ G(beta -\/ tau) acting on the values of the Green\textquotesingle{}s function at the DLR imaginary time nodes. This matrix is required for the reflect method. It is called automatically the first time the reflect method is called, but it may also be called manually to avoid the additional overhead of the first call to reflect. \mbox{\Hypertarget{classcppdlr_1_1imtime__ops_af958ce61d0c823b2a356b13c3fa10f3d}\label{classcppdlr_1_1imtime__ops_af958ce61d0c823b2a356b13c3fa10f3d}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!serialize@{serialize}}
\index{serialize@{serialize}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{serialize()}{serialize()}}
{\footnotesize\ttfamily void cppdlr\+::imtime\+\_\+ops\+::serialize (\begin{DoxyParamCaption}\item[{auto \&}]{ar }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Serialize the object into an archive by serializing all its members. The archive parameter must support the operator\& to serialize each member.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ar} & Archive to serialize into \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_ae6116f42e1f17050404974d0d6d3d226}\label{classcppdlr_1_1imtime__ops_ae6116f42e1f17050404974d0d6d3d226}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!tconvolve\_init@{tconvolve\_init}}
\index{tconvolve\_init@{tconvolve\_init}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{tconvolve\_init()}{tconvolve\_init()}}
{\footnotesize\ttfamily void cppdlr\+::imtime\+\_\+ops\+::tconvolve\+\_\+init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Initialization for time-\/ordered convolution methods. 

Initialize matrices required for the time-\/ordered convolution methods. This method is called automatically the first time one of the relevant time-\/ordered convolution methods is called, but it may also be called manually to avoid the additional overhead in the first time-\/ordered convolution call. \mbox{\Hypertarget{classcppdlr_1_1imtime__ops_af5bafac0dcc76bd713c732a3792c6e0c}\label{classcppdlr_1_1imtime__ops_af5bafac0dcc76bd713c732a3792c6e0c}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!vals2coefs@{vals2coefs}}
\index{vals2coefs@{vals2coefs}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{vals2coefs()}{vals2coefs()}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S = nda\+::get\+\_\+value\+\_\+t$<$\+T$>$$>$ \\
T\+::regular\+\_\+type cppdlr\+::imtime\+\_\+ops\+::vals2coefs (\begin{DoxyParamCaption}\item[{T const \&}]{g,  }\item[{bool}]{transpose = {\ttfamily false} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Transform values of Green\textquotesingle{}s function G on DLR imaginary time grid to DLR coefficients. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em g} & Values of G on DLR imaginary time grid \\
\hline
\mbox{\texttt{ in}}  & {\em transpose} & Transpose values -\/$>$ coefficients transformation (default is false)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
DLR coefficients of G (if transpose = false, as it is by default; otherwise, see note below)
\end{DoxyReturn}
\begin{DoxyNote}{Note}
By setting the optional argument {\ttfamily transpose} to true, this method applies the transpose of the values -\/$>$ coefficients transformation. This is useful for constructing matrices of linear operators which act on vectors of DLR grid values, rather than DLR coefficients. As an example, suppose L is a linear functional such that L\mbox{[}G\mbox{]} = c, G is a Green\textquotesingle{}s function and c is a scalar. If gc is the vector of DLR coefficient of G, then we can represent L by a vector l, with entries given by the action of L on the DLR basis functions, and we have l$^\wedge$T $\ast$ gc = c. Then
\end{DoxyNote}
c = l$^\wedge$T $\ast$ it2cf $\ast$ g = (it2cf$^\wedge$T $\ast$ l)$^\wedge$T $\ast$ g,

where g is the vector of values of G at the DLR nodes, and it2cf is the imaginary time values -\/$>$ coefficients matrix. Thus it2cf$^\wedge$T $\ast$ l is the vector of the linear operator T acting on the vector of values of G at the DLR nodes, and can be precomputed using the vals2coefs method with the transpose option set to true. 

\doxysubsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a02e5f8519e54734a74b94226d10e082d}\label{classcppdlr_1_1imtime__ops_a02e5f8519e54734a74b94226d10e082d}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!h5\_read@{h5\_read}}
\index{h5\_read@{h5\_read}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{h5\_read}{h5\_read}}
{\footnotesize\ttfamily void h5\+\_\+read (\begin{DoxyParamCaption}\item[{h5\+::group}]{fg,  }\item[{std\+::string const \&}]{subgroup\+\_\+name,  }\item[{\mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}} \&}]{m }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a0eec6aaaea35d7bba7e92951a0de76db}\label{classcppdlr_1_1imtime__ops_a0eec6aaaea35d7bba7e92951a0de76db}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!h5\_write@{h5\_write}}
\index{h5\_write@{h5\_write}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{h5\_write}{h5\_write}}
{\footnotesize\ttfamily void h5\+\_\+write (\begin{DoxyParamCaption}\item[{h5\+::group}]{fg,  }\item[{std\+::string const \&}]{subgroup\+\_\+name,  }\item[{\mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}} const \&}]{m }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a83e9085aca345c3bf889ae006f0fdb3d}\label{classcppdlr_1_1imtime__ops_a83e9085aca345c3bf889ae006f0fdb3d}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!lu@{lu}}
\index{lu@{lu}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{lu}{lu}}
{\footnotesize\ttfamily nda\+::matrix$<$double$>$ cppdlr\+::imtime\+\_\+ops\+::lu}



LU factors (LAPACK format) of imaginary time vals -\/$>$ coefs matrix. 

\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a7cd0e6b5498400d3afade53a6ebab389}\label{classcppdlr_1_1imtime__ops_a7cd0e6b5498400d3afade53a6ebab389}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!piv@{piv}}
\index{piv@{piv}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{piv}{piv}}
{\footnotesize\ttfamily nda\+::vector$<$int$>$ cppdlr\+::imtime\+\_\+ops\+::piv}



LU pivots (LAPACK format) of imaginary time vals -\/$>$ coefs matrix. 

\mbox{\Hypertarget{classcppdlr_1_1imtime__ops_a4868c3d774292b4d3610ac3225682bc0}\label{classcppdlr_1_1imtime__ops_a4868c3d774292b4d3610ac3225682bc0}} 
\index{cppdlr::imtime\_ops@{cppdlr::imtime\_ops}!zlu@{zlu}}
\index{zlu@{zlu}!cppdlr::imtime\_ops@{cppdlr::imtime\_ops}}
\doxysubsubsection{\texorpdfstring{zlu}{zlu}}
{\footnotesize\ttfamily nda\+::matrix$<$dcomplex$>$ cppdlr\+::imtime\+\_\+ops\+::zlu}



Same as lu, cast to complex (for use with lapack\+::getrs w/ cmplx input) 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/runner/work/cppdlr/cppdlr/c++/cppdlr/\mbox{\hyperlink{dlr__imtime_8hpp}{dlr\+\_\+imtime.\+hpp}}\item 
/home/runner/work/cppdlr/cppdlr/c++/cppdlr/\mbox{\hyperlink{dlr__imtime_8cpp}{dlr\+\_\+imtime.\+cpp}}\end{DoxyCompactItemize}
